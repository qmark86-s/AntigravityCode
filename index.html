<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weapon Master v2.2</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+KR:wght@400;500;700&family=Rajdhani:wght@500;600;700&display=swap"
        rel="stylesheet">

    <script src="js/three.min.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <script src="js/game_assets.js"></script>
    <style>
        /* CSS Variables for Design System */
        :root {
            /* Typography */
            --font-heading: 'Orbitron', sans-serif;
            --font-body: 'Noto Sans KR', 'Segoe UI', sans-serif;
            --font-numbers: 'Rajdhani', sans-serif;

            /* Primary Colors */
            --color-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --color-primary-solid: #667eea;
            --color-secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --color-secondary-solid: #f093fb;

            /* Status Colors */
            --color-success: linear-gradient(135deg, #0ba360 0%, #3cba92 100%);
            --color-success-solid: #0ba360;
            --color-danger: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --color-danger-solid: #fa709a;
            --color-gold: linear-gradient(135deg, #f9d423 0%, #ff4e50 100%);
            --color-gold-solid: #f9d423;

            /* UI Colors */
            --color-bg-dark: #0a0a0a;
            --color-bg-card: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --color-border: rgba(255, 255, 255, 0.1);
            --color-border-hover: rgba(255, 255, 255, 0.3);

            /* Glassmorphism */
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.18);
            --glass-blur: blur(10px);

            /* Shadows */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 8px 32px rgba(31, 38, 135, 0.37);
            --shadow-glow: 0 0 20px rgba(102, 126, 234, 0.5);

            /* Transitions */
            --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* ===== GLOBAL RESET (Mobile-First) ===== */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        html {
            height: 100%;
            height: 100dvh;
        }

        body {
            background: var(--color-bg-dark);
            color: #fff;
            font-family: var(--font-body);
            margin: 0;
            padding: 0;
            height: 100%;
            height: 100dvh;
            overflow: hidden;
            /* Prevent scroll - app-like */
            user-select: none;
            /* Safe Area padding applied to specific elements, not body */
        }

        /* 전역 스크롤바 스타일 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* 공통 오버레이 윈도우 스타일 */
        .overlay-window {
            max-height: 80vh;
            overflow-y: auto;
        }

        /* ===== VIEWPORT SCALING SYSTEM ===== */
        /* 
         * Letterbox Scaling: Game designed at 400x300, scaled to fit any screen.
         * This results in 2x larger content on mobile vs 800x600.
         * JavaScript calculates scale factor, CSS applies transform.
         */

        /* Scaler Wrapper - Centers and scales the game */
        /* Scale wrapper not needed for responsive 3D, but kept for legacy or overlay UI if needed. 
           Actually, for mixed mode (3D full, UI overlay), we want container to match window. */
        #game-scaler {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            background: transparent;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* UI Panel styling is now defined later in the file (line ~760) */

        #ui-panel .btn-small {
            padding: 4px 6px;
            font-size: 9px;
        }

        /* Stat Panel - ABOVE UI Panel (fixed, higher z-index) */
        #stat-panel {
            position: fixed;
            bottom: 90px;
            /* Above the UI panel */
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            padding: 8px;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
            border: 1px solid #0f3460;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            box-sizing: border-box;
            z-index: 1010;
            /* Higher than UI panel (1000) */
            font-size: 9px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        /* Stage Bar - Top of game container */
        #stage-display-bar {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 999;
            font-size: 11px;
            padding: 4px 12px;
        }

        /* Responsive Layout - Tablet & Mobile (Standardized) */
        @media (max-width: 1024px) {

            /* Increased breakpoint for better tablet support */
            body {
                padding: 0;
                overflow: hidden;
                /* Prevent body scroll */
                height: 100vh;
                height: 100dvh;
            }

            #game-container {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                border: none;
                border-radius: 0;
                box-shadow: none;
                max-width: none;
                position: fixed;
                top: 0;
                left: 0;
                z-index: 0;
            }

            /* UI Panel floats at bottom */
            /* UI Panel - Unified HUD handles this globally now */

            /* Log Box Repositioning - Top Left below Stage Bar */
            #log-box {
                top: 70px;
                left: 10px;
                bottom: auto;
                width: 180px;
                height: 100px;
                font-size: 11px;
                background: rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(4px);
                pointer-events: none;
                /* Click through */
            }

            /* Overlays: Full Screen when visible (JS controls display) */
            .overlay-window,
            .shop-window,
            .stat-window,
            #settings-overlay,
            #gacha-overlay,
            #smith-overlay,
            #shop-overlay,
            #inventory-overlay,
            #stat-overlay {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                max-width: 100% !important;
                max-height: 100% !important;
                border-radius: 0 !important;
                background: rgba(0, 0, 0, 0.95) !important;
                z-index: 2000 !important;
                padding: env(safe-area-inset-top, 20px) env(safe-area-inset-right, 20px) env(safe-area-inset-bottom, 20px) env(safe-area-inset-left, 20px) !important;
                box-sizing: border-box;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Modal content centering */
            #settings-overlay>*,
            #gacha-overlay>*,
            #smith-overlay>*,
            #shop-overlay>*,
            #inventory-overlay>*,
            #stat-overlay>* {
                max-width: 95%;
                margin: 0 auto;
            }

            /* Responsive Stat Panel (Bottom Panel 1) */
            #stat-panel {
                width: 100% !important;
                margin: 0 !important;
                border-radius: 0 !important;
                border: none !important;
                border-top: 2px solid #333 !important;
                background: rgba(0, 0, 0, 0.85) !important;
                position: fixed;
                bottom: 0px;
                /* Behind UI panel or part of it? */
                /* User said "Bottom 2 panels", referring to UI and maybe this.
                   Actually, let's Hide text stats on main screen mobile to clear view?
                   Or make them very small. Let's make them fit. */
                display: none !important;
                /* Hide on mobile main screen to be cleaner, showing only inside Stat Menu */
            }

            /* Stage Bar */
            #stage-display-bar {
                top: calc(10px + env(safe-area-inset-top, 0));
                width: auto;
                min-width: 200px;
                padding: 8px 20px;
                border-radius: 30px;
                font-size: 14px;
            }

            /* Ally/Interact Buttons */
            .ally-btn {
                bottom: calc(90px + env(safe-area-inset-bottom, 0));
                /* Clear UI panel */
                width: 55px;
                height: 55px;
                right: 15px;
                /* Anchor to right */
                left: auto;
                /* Reset left */
                transform: none;
                /* Reset center translate */
            }

            /* Grids */
            .weapon-grid,
            .inventory-grid {
                grid-template-columns: repeat(auto-fill, minmax(65px, 1fr)) !important;
                gap: 8px !important;
                width: 100%;
                box-sizing: border-box;
            }

            .btn-small {
                padding: 10px 15px;
                font-size: 14px;
            }
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* Below UI but above base */
        }

        /* Disable old CSS tunnel */
        .tunnel-container {
            display: none !important;
        }

        .ally-btn {
            position: absolute;
            top: 50%;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            cursor: pointer;
            z-index: 100;
            user-select: none;
            text-align: center;
            transform: translateY(-50%);
            transition: 0.2s;
        }

        .ally-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-50%) scale(1.1);
        }

        /* Hide ally buttons when overlays are open */
        #shop-overlay:not([style*="display: none"])~#game-container .ally-btn,
        #gacha-overlay:not([style*="display: none"])~#game-container .ally-btn,
        #stat-overlay:not([style*="display: none"])~#game-container .ally-btn,
        #inventory-overlay:not([style*="display: none"])~#game-container .ally-btn,
        #settings-overlay:not([style*="display: none"])~#game-container .ally-btn,
        #smith-overlay:not([style*="display: none"])~#game-container .ally-btn {
            display: none !important;
        }

        /* Stage Display Bar */
        #stage-display-bar {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            /* Increased to ensure always on top */
            background: linear-gradient(135deg, rgba(46, 49, 65, 0.95), rgba(30, 33, 48, 0.95));
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: none;
            border-radius: 0 0 20px 20px;
            padding: 12px 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(124, 77, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 20px;
            font-family: var(--font-heading);
            transition: all 0.3s ease;
        }

        #stage-display-bar.boss-stage {
            border-color: rgba(255, 77, 77, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(255, 77, 77, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: bossPulse 1.5s ease-in-out infinite;
        }

        @keyframes bossPulse {

            0%,
            100% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.02);
            }
        }

        .stage-info-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .stage-info-item .stage-icon {
            font-size: 20px;
            filter: drop-shadow(0 0 8px currentColor);
        }

        .stage-info-item .stage-value {
            background: linear-gradient(135deg, var(--gradient-primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 18px;
            font-weight: 700;
        }

        .stage-info-item.world-info .stage-value {
            background: linear-gradient(135deg, #00d4ff, #7c4dff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stage-info-item.boss-indicator {
            background: linear-gradient(135deg, #ff4d4d, #ff9800);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
            box-shadow: 0 0 20px rgba(255, 77, 77, 0.6);
            animation: bossGlow 1s ease-in-out infinite alternate;
        }

        @keyframes bossGlow {
            from {
                box-shadow: 0 0 20px rgba(255, 77, 77, 0.6);
            }

            to {
                box-shadow: 0 0 30px rgba(255, 77, 77, 1);
            }
        }

        /* Phase 6: Hit Flash Effect */
        @keyframes hitFlashAnim {
            0% {
                filter: brightness(5) drop-shadow(0 0 10px white);
            }

            50% {
                filter: brightness(2);
            }

            100% {
                filter: brightness(1);
            }
        }

        .hit-flash {
            animation: hitFlashAnim 0.15s ease-out !important;
        }

        .stage-separator {
            width: 2px;
            height: 20px;
            background: linear-gradient(180deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        }

        /* Slot Selection Screen - Scaled for 400x300 */
        #slot-select-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2100;
            /* Highest */
            color: white;
        }

        #slot-select-screen h1 {
            font-size: 24px;
            margin-bottom: 15px;
        }

        .slot-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .save-slot,
        .slot-card {
            width: 90px;
            height: 130px;
            border: 2px solid #555;
            background: #222;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            padding: 5px;
        }

        .save-slot:hover,
        .slot-card:hover {
            border-color: #fff;
            transform: scale(1.05);
            background: #333;
        }

        .slot-title {
            font-size: 14px;
            font-weight: bold;
            color: #f1c40f;
            margin-bottom: 5px;
        }

        .slot-info {
            font-size: 10px;
            color: #aaa;
            text-align: center;
        }

        .slot-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .ally-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            /* Responsive: Scale with viewport min dimension */
            width: 12vmin;
            height: 12vmin;
            min-width: 50px;
            min-height: 50px;
            max-width: 80px;
            max-height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #7f8c8d;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 900;
            color: white;
            transition: all 0.2s;
            user-select: none;
            font-size: 2.5vmin;
        }

        /* Mobile Layout: Prevent overlap with center area */
        @media (max-width: 600px) {
            .ally-btn {
                width: 14vmin;
                height: 14vmin;
                border-width: 2px;
            }

            #ally-slot-left {
                left: 5px !important;
            }

            #ally-slot-right {
                right: 5px !important;
            }
        }

        .ally-btn:hover {
            transform: translateY(-50%) scale(1.1);
            background: rgba(0, 0, 0, 0.8);
            border-color: white;
        }

        .slot-card {
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            padding: 10px;
            box-sizing: border-box;
        }

        .slot-card:hover {
            border-color: #fff;
            transform: scale(1.05);
            background: #333;
        }

        .slot-card.locked {
            border-color: #f1c40f;
            opacity: 0.7;
        }

        .slot-card.empty {
            border-style: dashed;
            opacity: 0.6;
        }

        .slot-header {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
        }

        .slot-lv {
            font-size: 12px;
            background: #2ecc71;
            padding: 2px 5px;
            border-radius: 4px;
            color: #000;
            font-weight: bold;
        }

        .slot-detail {
            font-size: 14px;
            margin: 2px 0;
            color: #ccc;
        }

        .slot-time {
            font-size: 10px;
            color: #777;
            margin-top: 10px;
        }

        .slot-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }

        .slot-price {
            margin-top: 5px;
            color: #f1c40f;
            font-size: 12px;
        }

        /* 2D UI Layers - Enemy Container (Always Centered) */
        #enemy-container {
            position: absolute;
            top: 60%;
            /* Moved down from 40% to sit on the floor */
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: none;
        }

        /* Enemy Appearance Animation (Zoom In) */
        @keyframes enemyApproach {
            0% {
                opacity: 0;
                transform: scale(0.1) translateY(100px);
                /* Start small and low */
            }

            100% {
                opacity: 1;
                transform: scale(1.2) translateY(0);
                /* Pop out slightly larger */
            }
        }

        .enemy-approaching #enemy-content {
            animation: enemyApproach 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            /* Bouncy pop */
        }

        /* Enemy Appearance Animation */
        @keyframes enemyApproach {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(50px);
            }

            100% {
                opacity: 1;
                transform: scale(1.0) translateY(0);
            }
        }

        .enemy-approaching #enemy-content {
            animation: enemyApproach 0.5s ease-out forwards;
        }

        .slot-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ff9800;
        }

        .slot-info {
            font-size: 0.9rem;
            color: #aaa;
            text-align: center;
            line-height: 1.4;
        }

        /* UI Panel - Unified Full Width HUD */
        #ui-panel {
            position: fixed !important;
            bottom: 0 !important;
            left: 0 !important;
            width: 100% !important;
            max-width: none !important;
            /* Force full width */
            display: flex;
            justify-content: center;
            z-index: 1000;
            padding-bottom: env(safe-area-inset-bottom, 0);
            /* Full Width Background Gradient - Matches Top Bar Style */
            background: linear-gradient(to top, rgba(10, 10, 20, 0.98), rgba(26, 26, 46, 0.95)) !important;
            border-top: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5),
                0 0 15px rgba(102, 126, 234, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 0 !important;
        }

        .ui-panel-content {
            /* Now acts as a centered container WITHIN the full bar */
            width: 100%;
            max-width: 1000px !important;
            /* Increased from 650px to allow spreading */
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            color: white;
            /* Remove bubble styles */
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            border-radius: 0 !important;
        }

        /* Player Info Section */
        .ui-panel-content .player-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            /* Allow to grow */
            min-width: 120px;
        }

        .ui-panel-content .player-info .level-hp {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            font-weight: bold;
            white-space: nowrap;
        }

        /* Scale the game to fit the viewport */
        #game-scaler {
            transform-origin: top left;
            /* Phase 11: Strict Flex Layout */
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        #game-container {
            /* Phase 11: Flexible Game Area */
            flex: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
            background: radial-gradient(circle at center, #2a2a3d 0%, #000 100%);
            /* Ensure children (overlays) are positioned relative to this */
        }

        .ui-panel-content .exp-bar-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .ui-panel-content .exp-text {
            font-size: 10px;
            color: #aaa;
        }

        /* Weapon Info Middle Section */
        .ui-panel-content .weapon-info {
            display: flex;
            flex-direction: column;
            /* Stacked */
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 0 20px;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            flex: 1;
            white-space: nowrap;
        }

        .ui-panel-content .weapon-name {
            font-size: 13px;
            font-weight: bold;
            color: #ecf0f1;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ui-panel-content .currency {
            font-size: 11px;
            display: flex;
            gap: 10px;
        }

        /* Menu Grid */
        .menu-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-menu {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn-menu:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* Notification Badge */
        .notification-dot {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 8px;
            height: 8px;
            background: #e74c3c;
            border-radius: 50%;
            border: 1px solid #fff;
            box-shadow: 0 0 5px #e74c3c;
            display: none;
            /* JS toggles this */
            z-index: 10;
        }

        .notification-dot.active {
            display: block;
        }

        /* Mobile specific adjustments for the new HUD */
        @media (max-width: 600px) {
            .ui-panel-content {
                gap: 5px;
                padding: 8px 10px;
                flex-wrap: wrap;
                /* Allow wrapping */
            }

            .ui-panel-content .player-info {
                flex: 1 1 auto;
                /* Take space */
                min-width: 120px;
                order: 1;
            }

            .ui-panel-content .weapon-info {
                display: flex !important;
                /* Force Show */
                flex: 1 1 auto;
                border: none;
                padding: 0;
                justify-content: flex-end;
                /* Align right */
                order: 2;
                font-size: 11px;
            }

            /* Stack Menu Grid on next row */
            .menu-grid {
                order: 3;
                width: 100%;
                grid-template-columns: repeat(6, 1fr);
                /* 6 columns for 6 buttons */
                gap: 4px;
                margin-top: 4px;
                padding-top: 4px;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }

            .btn-menu {
                padding: 6px 2px;
                font-size: 10px;
                text-align: center;
            }

            #ui-weapon-icon {
                font-size: 16px;
            }

            #ui-weapon {
                max-width: 80px;
                overflow: hidden;
                text-overflow: ellipsis;
            }
        }

        .btn-menu:active {
            transform: translateY(1px);
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* End of btn-menu styles */

        /* Responsive: Tablet */
        @media (max-width: 650px) {
            .ui-panel-content {
                padding: 6px 10px;
                gap: 8px;
            }

            .menu-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .btn-menu {
                font-size: 9px;
                padding: 5px 6px;
            }

            .ui-panel-content .weapon-info {
                padding: 0 8px;
            }
        }

        /* Responsive: Mobile */
        @media (max-width: 480px) {
            /* Handled by global HUD style now */

            .btn-menu {
                padding: 4px;
            }
        }

        .ui-panel-content {
            flex-direction: column;
            gap: 6px;
            padding: 8px;
        }

        .ui-panel-content .player-info {
            flex-direction: row;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .ui-panel-content .weapon-info {
            flex-direction: row;
            border: none;
            padding: 0;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }

        .menu-grid {
            grid-template-columns: repeat(6, 1fr);
            width: 100%;
        }

        .btn-menu {
            font-size: 8px;
            padding: 4px 2px;
            min-width: 0;
        }

        /* Stat panel adjustments for mobile */
        /* #stat-panel removed */


        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .big-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #e74c3c;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 10px;
            font-weight: bold;
            transition: 0.2s;
        }

        .big-btn:hover {
            transform: scale(1.05);
            background: #c0392b;
        }

        .tunnel-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            perspective: 500px;
        }

        .face {
            position: absolute;
            background-size: 128px 128px;
            image-rendering: auto;
            transition: background-image 0.5s;
        }

        .wall-left {
            width: 2000px;
            height: 100%;
            left: 0;
            top: 0;
            transform-origin: left;
            transform: rotateY(90deg) translateX(-500px);
            background-color: #2a2a2a;
        }

        .wall-right {
            width: 2000px;
            height: 100%;
            right: 0;
            top: 0;
            transform-origin: right;
            transform: rotateY(-90deg) translateX(500px);
            background-color: #2a2a2a;
        }

        .floor {
            width: 100%;
            height: 2000px;
            bottom: 0;
            left: 0;
            transform-origin: bottom;
            transform: rotateX(90deg) translateY(300px);
            background-color: #1a1a1a;
        }

        .ceiling {
            width: 100%;
            height: 2000px;
            top: 0;
            left: 0;
            transform-origin: top;
            transform: rotateX(-90deg) translateY(-500px);
            background-color: #050505;
        }

        /* 벽면: 좌우 스크롤 (앞으로 진행 느낌) */
        .moving .wall-left {
            animation: scrollWallLeft 0.5s linear infinite;
        }

        .moving .wall-right {
            animation: scrollWallRight 0.5s linear infinite;
        }

        /* 바닥/천장: 앞에서 뒤로 스크롤 */
        .moving .floor,
        .moving .ceiling {
            animation: scrollFloor 0.5s linear infinite;
        }

        @keyframes scrollWallLeft {
            from {
                background-position: 0 0;
            }

            to {
                background-position: -128px 0;
            }
        }

        @keyframes scrollWallRight {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 128px 0;
            }
        }

        @keyframes scrollFloor {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 0 128px;
            }
        }

        /* 몬스터 컨테이너 - 소실점(터널 안쪽)에 배치 */


        #enemy-emoji {
            font-size: 80px;
            filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.8));
        }

        #enemy-img {
            width: 150px;
            height: 150px;
            display: none;
            object-fit: contain;
            filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.6));
            animation: enemyApproach 0.5s ease-out;
        }

        /* 몬스터가 소실점(멀리)에서 다가오는 애니메이션 */
        /* 몬스터가 소실점(멀리)에서 다가오는 애니메이션 (Zoom-in) */
        @keyframes enemyApproach {
            0% {
                transform: scale(0.1);
                opacity: 0;
            }

            100% {
                transform: scale(1.0);
                opacity: 1;
            }
        }

        #enemy-hud {
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        /* Shimmer animation for HP bars */
        @keyframes shimmer {
            0% {
                left: -100%;
            }

            100% {
                left: 100%;
            }
        }

        #hp-bar-enemy {
            width: 200px;
            height: 12px;
            background: #333;
            margin: 10px auto;
            border-radius: 6px;
            overflow: hidden;
        }

        #hp-fill-enemy {
            height: 100%;
            width: 100%;
            background: var(--color-danger);
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px rgba(250, 112, 154, 0.6);
            position: relative;
            overflow: hidden;
        }

        #hp-fill-enemy::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        /* 1인칭 손 - 화면 최전방 */
        #hands {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            gap: 30px;
            pointer-events: none;
            z-index: 100;
        }

        .hand-slot {
            font-size: 120px;
            filter: drop-shadow(5px 10px 20px rgba(0, 0, 0, 0.8));
            transition: transform 0.1s;
        }

        .hand-img {
            width: 150px;
            height: 150px;
            object-fit: contain;
            transform: scaleX(-1);
        }

        /* 1인칭 펀치 - 몬스터(앞/위쪽)를 향해 공격 */
        #right-hand.attack-anim {
            animation: punchForward 0.15s ease-out;
        }

        @keyframes punchForward {
            0% {
                transform: translateY(0) scale(1);
            }

            50% {
                transform: translateY(-200px) scale(0.6);
            }

            100% {
                transform: translateY(0) scale(1);
            }
        }

        #ui-panel {
            /* Phase 11: UI Panel Constraints */
            flex: 0 0 auto;
            /* Don't grow, don't shrink */
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            /* Center horizontally */

            padding: 10px 15px;
            background: var(--color-bg-card);
            border-top: 2px solid var(--color-border);
            /* Border top only usually looks better for panels */
            /* border-radius: 12px 12px 0 0; Optional rounded top */
            align-items: center;
            box-sizing: border-box;
            box-shadow: var(--shadow-md);
            /* Ensure panel stays above overlays (though flex structure separates them naturally now) */
            position: relative;
            z-index: 2500;
        }

        .btn-small {
            padding: 8px 15px;
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            color: white;
            border: 1px solid var(--glass-border);
            cursor: pointer;
            border-radius: 8px;
            margin: 0 3px;
            font-family: var(--font-body);
            font-weight: 500;
            transition: all var(--transition-base);
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }

        .btn-small::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left var(--transition-slow);
        }

        .btn-small:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            border-color: var(--color-border-hover);
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-small:hover::before {
            left: 100%;
        }

        .btn-small:active {
            transform: translateY(0);
        }

        .gold-txt {
            background: var(--color-gold);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
            font-size: 18px;
            font-family: var(--font-numbers);
            text-shadow: 0 0 20px rgba(249, 212, 35, 0.5);
            filter: drop-shadow(0 0 10px rgba(249, 212, 35, 0.3));
        }

        #shop-overlay {
            /* Phase 11: Constrain to Game Container */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;

            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            overflow-y: auto;
        }

        .shop-window {
            background: linear-gradient(145deg, #1a1a2e, #16213e) padding-box,
                var(--color-primary) border-box;
            padding: 30px;
            border-radius: 20px;
            border: 2px solid transparent;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg), var(--shadow-glow);
            position: relative;
        }

        .shop-window h2 {
            font-family: var(--font-heading);
            color: transparent;
            background: var(--color-gold);
            -webkit-background-clip: text;
            background-clip: text;
            text-shadow: 0 0 30px rgba(249, 212, 35, 0.5);
            font-weight: 900;
            letter-spacing: 2px;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            margin: 10px 0;
            background: var(--glass-bg);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            cursor: pointer;
            transition: all var(--transition-base);
            position: relative;
            overflow: hidden;
        }

        .shop-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent);
            transition: left var(--transition-slow);
        }

        .shop-item:hover {
            background: rgba(102, 126, 234, 0.15);
            border-color: var(--color-primary-solid);
            transform: translateX(5px);
            box-shadow: var(--shadow-md);
        }

        .shop-item:hover::before {
            left: 100%;
        }

        #stat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            overflow-y: auto;
        }

        .stat-window {
            background: linear-gradient(145deg, #1a1a2e, #16213e) padding-box,
                var(--color-secondary) border-box;
            padding: 30px;
            border-radius: 20px;
            border: 2px solid transparent;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg), 0 0 20px rgba(240, 147, 251, 0.3);
        }

        .stat-window h2 {
            font-family: var(--font-heading);
            font-weight: 900;
            letter-spacing: 2px;
        }

        #gacha-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            overflow-y: auto;
        }

        #settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            overflow-y: auto;
        }


        .res-row {
            display: flex;
            align-items: center;
            margin: 8px 0;
            gap: 10px;
        }

        .res-label {
            width: 80px;
        }

        .res-input {
            width: 300px;
            padding: 5px;
        }

        .res-preview {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .res-preview img {
            max-width: 50px;
            max-height: 50px;
        }

        .btn-save {
            background: #27ae60;
            color: white;
            padding: 10px 25px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 20px 5px;
        }

        .btn-reset {
            background: #e74c3c;
            color: white;
            padding: 10px 25px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 20px 5px;
        }

        #shop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1500;
            display: none;
            justify-content: center;
            align-items: center;
        }

        /* .shop-window moved to Shared Modal Styles */

        .shop-item {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s;
        }

        .shop-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        #log-box {
            position: absolute;
            left: 10px;
            bottom: 10px;
            width: 200px;
            /* Reduced from 250px to avoid overlap */
            height: 120px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            font-size: 12px;
            overflow-y: auto;
            border-radius: 5px;
            z-index: 100;
        }

        .dmg-text {
            position: absolute;
            top: 40%;
            left: 50%;
            font-size: 50px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 5px #000;
            pointer-events: none;
            animation: dmgUp 0.8s ease-out forwards;
            z-index: 200;
        }

        @keyframes dmgUp {
            0% {
                opacity: 1;
                transform: translate(-50%, 0);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -80px);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        /* Shake applied to game canvas wrapper, not game-container (preserves scale) */
        #game-canvas.shake {
            animation: shake 0.3s ease-in-out;
        }

        /* Stat Panel styles moved to viewport scaling section */

        .stat-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #333;
        }

        .stat-box .stat-icon {
            font-size: 24px;
        }

        .stat-box .stat-name {
            font-size: 11px;
            color: #888;
            margin: 5px 0 3px 0;
        }

        .stat-box .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
        }

        .stat-atk .stat-value {
            color: #e74c3c;
        }

        .stat-hp .stat-value {
            color: #2ecc71;
        }

        .stat-aspd .stat-value {
            color: #3498db;
        }

        .stat-crit .stat-value {
            color: #f39c12;
        }

        .stat-critdmg .stat-value {
            color: #9b59b6;
        }

        /* 스탯 분배 오버레이 */
        #stat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1500;
            display: none;
            justify-content: center;
            align-items: center;
        }

        /* .stat-window moved to Shared Modal Styles */

        .stat-window h2 {
            color: #f1c40f;
            margin-bottom: 10px;
        }

        .stat-points-display {
            font-size: 24px;
            color: #3498db;
            margin-bottom: 20px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
        }

        .stat-row-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-row-icon {
            font-size: 24px;
        }

        .stat-row-name {
            font-size: 14px;
            color: #aaa;
        }

        .stat-row-value {
            font-size: 18px;
            font-weight: bold;
            min-width: 80px;
        }

        .stat-row-invested {
            font-size: 12px;
            color: #888;
        }

        .stat-row-btns {
            display: flex;
            gap: 5px;
        }

        .stat-btn {
            width: 35px;
            height: 35px;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }

        .stat-btn-add {
            background: var(--color-success);
            color: white;
            box-shadow: 0 4px 12px rgba(11, 163, 96, 0.4);
        }

        .stat-btn-add:hover {
            background: var(--color-success);
            transform: scale(1.15);
            box-shadow: 0 6px 20px rgba(11, 163, 96, 0.6);
        }

        .stat-btn-add:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
        }

        .btn-reset-stats {
            margin-top: 20px;
            padding: 10px 25px;
            background: #c0392b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .btn-close-stats {
            margin-top: 15px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
            transition: 0.2s;
        }

        .btn-close-stats:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.6);
        }

        /* 대장간 스타일 */
        #smith-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: flex-start;
            overflow-y: auto;
            padding-top: 30px;
            box-sizing: border-box;
        }

        /* Shared Modal Window Styles for Scrolling */
        .shop-window,
        .stat-window,
        .smith-window,
        .settings-window {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 25px;
            border-radius: 15px;
            /* Responsive Width */
            width: 90vw;
            max-width: 500px;

            /* Vertical Scrolling Support */
            max-height: 85vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            box-sizing: border-box;

            /* Border & Shadow */
            border: 2px solid #fff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);

            /* Phase 11: Clean up Legacy Hacks 
               No longer need margin-bottom or calc height if container is flex:1 
               But to be safe, let's keep max-height reasonable */
            max-height: 90%;
        }



        .stat-window {
            border-color: #f1c40f;
            text-align: center;
        }

        .smith-window {
            background: linear-gradient(135deg, #2d1f1f, #1a1a2e);
            border-color: #e67e22;
        }

        .settings-window {
            border-color: #95a5a6;
            text-align: center;
        }

        .smith-tab {
            padding: 10px 20px;
            background: #444;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
        }

        .smith-tab.active {
            background: linear-gradient(135deg, #e67e22, #d35400);
        }

        .synthesis-slots {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }

        .synthesis-slot {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px dashed #666;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: 0.2s;
        }

        .synthesis-slot:hover {
            border-color: #e67e22;
            background: rgba(230, 126, 34, 0.2);
        }

        .synthesis-slot.filled {
            border-style: solid;
            border-color: #27ae60;
        }

        .synthesis-slot img,
        .synthesis-slot span {
            width: 50px;
            height: 50px;
            object-fit: contain;
            font-size: 40px;
        }

        .synthesis-arrow {
            font-size: 30px;
            color: #e67e22;
        }

        .synthesis-result {
            width: 100px;
            height: 100px;
            background: rgba(230, 126, 34, 0.3);
            border: 3px solid #e67e22;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
        }

        .enhance-weapon-display {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
        }

        .enhance-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
        }

        .enhance-stat {
            text-align: center;
        }

        .enhance-stat-value {
            font-size: 24px;
            font-weight: bold;
        }

        .enhance-success {
            color: #27ae60;
        }

        .enhance-warning {
            color: #e74c3c;
        }

        .weapon-select-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            max-height: 200px;
            overflow-y: scroll;
            margin: 10px 0;
            padding-right: 5px;
        }

        .weapon-select-item {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: 0.2s;
        }

        .weapon-select-item:hover {
            border-color: #e67e22;
        }

        .weapon-select-item.selected {
            border-color: #27ae60;
            background: rgba(39, 174, 96, 0.2);
        }

        .weapon-select-item img {
            width: 35px;
            height: 35px;
            object-fit: contain;
        }

        .weapon-enhancement-badge {
            font-size: 10px;
            color: #f39c12;
            font-weight: bold;
        }

        /* Home Button Style */
        /* Home Button Style - Responsive */
        #btn-home {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 8vmin;
            height: 8vmin;
            min-width: 40px;
            min-height: 40px;
            max-width: 60px;
            max-height: 60px;
            font-size: 4vmin;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            color: #fff;
            border-radius: 50%;
            cursor: pointer;
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
        }

        #btn-home:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* Top Stage Bar - Responsive */
        #stage-display-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            z-index: 10;
            white-space: nowrap;
            width: fit-content;
            max-width: 60%;
            /* Ensure it doesn't overlap home button */
            transition: all 0.3s;
        }

        @media (max-width: 600px) {
            #btn-home {
                top: 10px;
                right: 10px;
                width: 10vmin;
                height: 10vmin;
            }

            #stage-display-bar {
                top: 10px;
                max-width: 70%;
                padding: 5px 15px;
            }

            /* Override inline font sizes for mobile */
            #stage-display-bar span {
                font-size: 3.5vmin !important;
            }
        }
    </style>
</head>

<body>
    <!-- Viewport Scaler Wrapper -->
    <div id="game-scaler">
        <div id="game-container">
            <!-- 3D Canvas (Background) -->
            <div id="game-canvas"></div>

            <!-- Old Tunnel (Hidden but kept for now) -->
            <div class="tunnel-container">
                <div class="wall-left face"></div>
                <div class="wall-right face"></div>
                <div class="floor face"></div>
                <div class="ceiling face"></div>
            </div>

            <!-- Enemy Container (Legacy Structure for JS compatibility) -->
            <button id="btn-home" onclick="game.confirmHome()">🏠</button>
            <div id="enemy-container">
                <!-- Legacy enemy-hud removed: now handled by top stage display bar -->
                <div id="enemy-content">
                    <div id="enemy-emoji"></div>
                    <img id="enemy-img" src="" alt="enemy">
                </div>
                <div id="hp-bar-enemy">
                    <div id="hp-fill-enemy"></div>
                </div>
            </div>

            <!-- Player Hands (Legacy Structure for JS compatibility) -->
            <div id="hands">
                <!-- Left hand placeholder if needed, or just right hand as per legacy -->
                <div id="right-hand" class="hand-slot">
                    <span id="hand-emoji">👊</span>
                    <img id="hand-img" class="hand-img" style="display:none;">
                </div>
            </div>

            <!-- Slot Selection Screen -->
            <!-- Slot Selection Screen -->
            <!-- Slot Selection Screen -->
            <div id="slot-select-screen" style="display:flex;">
                <button class="btn-close-slot" onclick="game.closeSlotScreen()"
                    style="position: absolute; top: 20px; right: 20px; font-size: 24px; background: transparent; border: none; color: white; cursor: pointer;">✕</button>
                <h1>Select Save Slot</h1>
                <div class="slot-container">
                    <div id="slot-1-card"></div>
                    <div id="slot-2-card"></div>
                    <div id="slot-3-card"></div>
                </div>
            </div>

            <!-- Persistent Stage Display Bar with Wave and Monster Info -->
            <div id="stage-display-bar">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 18px;">⚔️</span>
                    <span id="stage-display-text" style="font-weight: 600; font-size: 16px;">STAGE 1-1</span>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span id="stage-wave-info"
                        style="font-weight: 500; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Wave 1/10</span>
                    <span style="color: rgba(255, 255, 255, 0.5);">•</span>
                    <span id="stage-monster-name" style="font-weight: 500; font-size: 14px; color: #FFD700;">슬라임</span>
                </div>
            </div>
            <!-- Party Slots (UI Buttons) -->
            <div id="ally-slot-left" class="ally-btn" style="left: 20px;"></div>
            <div id="ally-slot-right" class="ally-btn" style="right: 20px;"></div>

            <div id="start-screen" style="display:none;">
                <h1 style="font-size:48px;text-shadow:0 0 20px #e74c3c">⚔️ Weapon Master</h1>
                <p style="color:#888">v2.3 - 3D Resources</p>
                <button class="big-btn" onclick="game.start()">🎮 모험 시작</button>
            </div>

            <!-- Missing Log Box Restored -->
            <div id="log-box"></div>




            <!-- 커스텀 확인 모달 -->
            <div id="confirm-modal"
                style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:9999;justify-content:center;align-items:center;">
                <div
                    style="background:linear-gradient(180deg,#2a2a3d,#1a1a2e);padding:30px;border-radius:15px;border:2px solid #8b5cf6;max-width:400px;text-align:center;box-shadow:0 0 30px rgba(139,92,246,0.5);">
                    <div id="modal-title" style="font-size:20px;font-weight:bold;color:#fff;margin-bottom:15px;"></div>
                    <div id="modal-message" style="color:#ccc;margin-bottom:25px;white-space:pre-line;line-height:1.6;">
                    </div>
                    <div id="modal-buttons" style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
                        <!-- 버튼들이 동적으로 생성됨 -->
                    </div>
                </div>
            </div>

            <div id="settings-overlay">
                <div class="settings-window">
                    <h1>⚙️ 설정</h1>

                    <!-- 캐릭터 슬롯 섹션 -->
                    <div style="margin:20px 0;background:rgba(0,0,0,0.5);padding:15px;border-radius:10px;">
                        <h2>💾 캐릭터 슬롯</h2>
                        <p style="font-size:12px;color:#888;margin-bottom:10px;">다이아는 모든 캐릭터가 공유합니다.</p>
                        <div id="slot-container" style="display:flex;gap:10px;justify-content:center;">
                            <!-- JS populated via game.updateSettingsSlotUI -->
                        </div>
                    </div>

                    <!-- 게임 설정 섹션 -->
                    <div style="margin:20px 0;background:rgba(0,0,0,0.5);padding:15px;border-radius:10px;">
                        <h2>🎮 게임 설정</h2>
                        <div style="display:flex;flex-direction:column;gap:10px;margin-top:10px;">
                            <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                                <input type="checkbox" id="opt-autosave" checked
                                    onchange="game.autoSave = this.checked; game.saveProgress();">
                                💾 자동저장
                            </label>
                            <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                                <input type="checkbox" id="opt-dmgtext" checked
                                    onchange="game.showDamageText = this.checked; game.saveProgress();">
                                💥 데미지 텍스트 표시
                            </label>
                        </div>
                        <button class="btn-reset" style="margin-top:15px;width:100%;" onclick="game.resetProgress()">🗑️
                            캐릭터
                            초기화</button>
                    </div>

                    <!-- 리소스 설정 섹션 -->
                    <div style="margin:20px 0">
                        <h2>🗡️ 무기</h2>
                        <div id="set-weapons"></div>
                        <h2>👾 몬스터</h2>
                        <div id="set-monsters"></div>
                        <h2>🌄 배경</h2>
                        <div id="set-backgrounds"></div>
                    </div>
                    <button class="btn-save" onclick="settings.save()">💾 리소스 저장</button>
                    <button class="btn-reset" onclick="settings.reset()">🔄 리소스 초기화</button>
                    <button class="btn-small" style="margin-top:20px" onclick="game.closeSettings()">닫기</button>
                </div>
            </div>

            <div id="shop-overlay">
                <div class="shop-window overlay-window" style="width:500px;max-height:70vh;overflow-y:auto;">
                    <h2 style="color:#f1c40f">⛺ 상점</h2>
                    <p>골드: <span id="shop-gold">0</span> G</p>

                    <!-- 현재 장비 상태 -->
                    <div style="background:rgba(0,0,0,0.5);padding:10px;border-radius:8px;margin-bottom:15px;">
                        <div style="font-size:14px;color:#888;margin-bottom:5px;">현재 장비</div>
                        <div style="display:flex;align-items:center;gap:10px;">
                            <span id="shop-weapon-icon" style="font-size:40px;">👊</span>
                            <div>
                                <div id="shop-weapon-name" style="font-weight:bold;">맨주먹</div>
                                <div id="shop-weapon-atk" style="color:#e74c3c;font-size:12px;">공격력 +0</div>
                            </div>
                        </div>
                    </div>

                    <!-- 탭 버튼 -->
                    <div style="display:flex;gap:5px;margin-bottom:10px;">
                        <button class="btn-small shop-tab active" onclick="game.switchShopTab('items')">💪 능력치</button>
                        <button class="btn-small shop-tab" onclick="game.switchShopTab('weapons')">🗡️ 무기</button>
                        <button class="btn-small shop-tab" onclick="game.switchShopTab('speed')">⚡ 배속</button>
                    </div>

                    <!-- 능력치 탭 -->
                    <div id="shop-items-tab">
                        <div class="shop-item" onclick="game.buy('hpBoost')"><span>❤️ 최대체력 +25</span><span
                                id="shop-cost-hpBoost">100G</span></div>
                        <div class="shop-item" onclick="game.buy('upgrade')"><span>💪 공격력 +5</span><span
                                id="shop-cost-atk">100G</span></div>
                        <div class="shop-item" onclick="game.buy('aspd')"><span>⚡ 공격속도 +0.1</span><span
                                id="shop-cost-aspd">150G</span></div>
                        <div class="shop-item" onclick="game.buy('critRate')"><span>🎯 치명타확률 +1%</span><span
                                id="shop-cost-critRate">200G</span></div>
                        <div class="shop-item" onclick="game.buy('critDmg')"><span>💥 치명타배수 +10%</span><span
                                id="shop-cost-critDmg">250G</span></div>
                    </div>

                    <!-- 무기 탭 -->
                    <div id="shop-weapons-tab" style="display:none;max-height:250px;overflow-y:auto;">
                        <!-- 동적 생성 -->
                    </div>

                    <!-- 배속 탭 -->
                    <div id="shop-speed-tab" style="display:none;">
                        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;margin-bottom:10px;">
                            <div style="color:#00bcd4;font-weight:bold;">현재 배속: <span
                                    id="shop-current-speed">1.0x</span>
                            </div>
                        </div>

                        <div style="color:#f1c40f;font-weight:bold;margin:10px 0;">💎 다이아 배속 (영구)</div>
                        <div id="speed-diamond-2x" class="shop-item" onclick="game.buyDiamondSpeed(1)">
                            <span>🚀 2배속</span><span>500💎</span>
                        </div>
                        <div id="speed-diamond-4x" class="shop-item" onclick="game.buyDiamondSpeed(2)">
                            <span>⚡ 4배속</span><span>2000💎</span>
                        </div>

                        <div style="color:#f39c12;font-weight:bold;margin:15px 0 10px;">🪙 골드 배속 (누적 +10%)</div>
                        <div id="speed-gold-upgrade" class="shop-item" onclick="game.buyGoldSpeed()">
                            <span>🔧 배속 강화 <span id="speed-gold-level">Lv.0/5</span></span>
                            <span id="speed-gold-price">1,000G</span>
                        </div>
                    </div>

                    <button class="btn-small" style="margin-top:10px;width:100%" onclick="game.closeShop()">나가기</button>
                </div>
            </div>

            <div id="stat-overlay">
                <div class="stat-window">
                    <h2>📊 스탯 분배</h2>
                    <div class="stat-points-display">보유 포인트: <span id="avail-points">0</span></div>
                    <div class="stat-row">
                        <div class="stat-row-info"><span class="stat-row-icon">⚔️</span><span
                                class="stat-row-name">공격력</span>
                        </div>
                        <span class="stat-row-value" id="sp-atk">10</span>
                        <span class="stat-row-invested" id="sp-atk-inv">(+0)</span>
                        <div class="stat-row-btns"><button class="stat-btn stat-btn-add"
                                onclick="game.investStat('atk')">+</button></div>
                    </div>
                    <div class="stat-row">
                        <div class="stat-row-info"><span class="stat-row-icon">❤️</span><span
                                class="stat-row-name">최대체력</span>
                        </div>
                        <span class="stat-row-value" id="sp-maxHp">100</span>
                        <span class="stat-row-invested" id="sp-maxHp-inv">(+0)</span>
                        <div class="stat-row-btns"><button class="stat-btn stat-btn-add"
                                onclick="game.investStat('maxHp')">+</button></div>
                    </div>
                    <div class="stat-row">
                        <div class="stat-row-info"><span class="stat-row-icon">⚡</span><span
                                class="stat-row-name">공격속도</span>
                        </div>
                        <span class="stat-row-value" id="sp-aspd">1.00</span>
                        <span class="stat-row-invested" id="sp-aspd-inv">(+0)</span>
                        <div class="stat-row-btns"><button class="stat-btn stat-btn-add"
                                onclick="game.investStat('aspd')">+</button></div>
                    </div>
                    <div class="stat-row">
                        <div class="stat-row-info"><span class="stat-row-icon">🎯</span><span
                                class="stat-row-name">치명타확률</span>
                        </div>
                        <span class="stat-row-value" id="sp-critRate">5%</span>
                        <span class="stat-row-invested" id="sp-critRate-inv">(+0)</span>
                        <div class="stat-row-btns"><button class="stat-btn stat-btn-add"
                                onclick="game.investStat('critRate')">+</button></div>
                    </div>
                    <div class="stat-row">
                        <div class="stat-row-info"><span class="stat-row-icon">💥</span><span
                                class="stat-row-name">치명타배수</span>
                        </div>
                        <span class="stat-row-value" id="sp-critDmg">150%</span>
                        <span class="stat-row-invested" id="sp-critDmg-inv">(+0)</span>
                        <div class="stat-row-btns"><button class="stat-btn stat-btn-add"
                                onclick="game.investStat('critDmg')">+</button></div>
                    </div>
                    <button class="btn-reset-stats" onclick="game.resetStats()">🔄 스탯 초기화</button>
                    <br>
                    <button class="btn-close-stats" onclick="game.closeStatPanel()">✓ 완료</button>
                </div>
            </div>

            <!-- 뽑기 오버레이 -->
            <div id="gacha-overlay">
                <div class="shop-window overlay-window"
                    style="width:500px;text-align:center;max-height:70vh;overflow-y:auto;">
                    <h2 style="color:#d35400">🔮 무기 소환</h2>
                    <div style="margin:20px 0;font-size:14px;color:#bdc3c7">
                        <p>전설 등장 확률: <span style="color:#f1c40f">1%</span></p>
                        <p>에픽 50회, 전설 100회 천장 시스템</p>
                        <p>보유 다이아: <span id="gacha-diamond">0</span> 💎</p>
                        <p style="font-size:12px;color:#888;">천장: <span id="gacha-pity">0</span>/100</p>
                    </div>
                    <div id="gacha-result" style="margin:20px 0;min-height:100px;display:none">
                        <!-- 결과 표시 영역 -->
                    </div>
                    <div style="display:flex;gap:10px;justify-content:center">
                        <button class="btn-save" onclick="game.doGacha(1)" style="flex:1">1회 (100💎)</button>
                        <button class="btn-save" onclick="game.doGacha(10)" style="flex:1">10회 (900💎)</button>
                    </div>
                    <button class="btn-small" style="margin-top:20px;width:100%" onclick="game.closeGacha()">닫기</button>
                </div>
            </div>

            <!-- 인벤토리 오버레이 -->
            <div id="inventory-overlay"
                style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:500;justify-content:center;align-items:flex-start;overflow-y:auto;padding-top:30px;box-sizing:border-box;">
                <div class="shop-window overlay-window"
                    style="width:500px;max-height:calc(100vh - 60px);overflow-y:auto;margin-bottom:30px;">
                    <h2 style="color:#8b5cf6">🎒 가방</h2>

                    <!-- 현재 장착 장비 -->
                    <div
                        style="background:rgba(139,92,246,0.2);padding:15px;border-radius:10px;margin-bottom:15px;border:2px solid #8b5cf6;">
                        <div style="font-size:14px;color:#888;margin-bottom:8px;">현재 장착</div>
                        <div id="inv-equipped" style="display:flex;align-items:center;gap:10px;min-height:50px;">
                            <!-- 장착 무기 표시 -->
                        </div>
                    </div>

                    <!-- 인벤토리 목록 -->
                    <div style="margin-bottom:15px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                            <span style="color:#888;">보유 장비 (<span id="inv-count">0</span>/90)</span>
                            <select id="inv-sort" onchange="game.sortInventory(this.value)"
                                style="padding:5px;border-radius:5px;background:#333;color:#fff;border:none;">
                                <option value="grade">등급순</option>
                                <option value="atk">공격력순</option>
                                <option value="name">이름순</option>
                            </select>
                        </div>
                        <div id="inv-list"
                            style="display:grid;grid-template-columns:repeat(6,1fr);gap:6px;max-height:250px;overflow-y:scroll;padding-right:5px;">
                            <!-- 인벤토리 아이템들 -->
                        </div>
                    </div>

                    <div
                        style="display:flex;gap:10px;position:sticky;bottom:0;background:linear-gradient(transparent,#1a1a2e 20%);padding-top:10px;">
                        <button class="btn-small" style="flex:1" onclick="game.openSmith()">🔨 대장간</button>
                        <button class="btn-small" style="flex:1" onclick="game.closeInventory()">닫기</button>
                    </div>
                </div>
            </div>

            <!-- 대장간 오버레이 -->
            <div id="smith-overlay">
                <div class="smith-window">
                    <h2 style="color:#e67e22;text-align:center">🔨 대장간</h2>

                    <!-- 탭 버튼 -->
                    <div style="display:flex;gap:5px;margin-bottom:15px;">
                        <button class="smith-tab active" onclick="game.switchSmithTab('synthesis')">⚗️ 합성</button>
                        <button class="smith-tab" onclick="game.switchSmithTab('enhance')">⬆️ 강화</button>
                    </div>

                    <!-- 합성 탭 -->
                    <div id="smith-synthesis-tab">
                        <p style="text-align:center;color:#888;font-size:13px;">같은 등급 무기 3개 → 상위 등급 무기 1개</p>

                        <div class="synthesis-slots">
                            <div class="synthesis-slot" id="synth-slot-0" onclick="game.selectSynthesisSlot(0)">
                                <span style="color:#666">+</span>
                            </div>
                            <div class="synthesis-slot" id="synth-slot-1" onclick="game.selectSynthesisSlot(1)">
                                <span style="color:#666">+</span>
                            </div>
                            <div class="synthesis-slot" id="synth-slot-2" onclick="game.selectSynthesisSlot(2)">
                                <span style="color:#666">+</span>
                            </div>
                            <span class="synthesis-arrow">→</span>
                            <div class="synthesis-result" id="synth-result">
                                <span style="color:#666">?</span>
                            </div>
                        </div>

                        <div style="text-align:center;margin:10px 0;">
                            <span id="synth-grade-info" style="color:#888;">등급을 선택하세요</span>
                        </div>

                        <!-- 합성 능력치 미리보기 -->
                        <div id="synth-preview"
                            style="background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;margin:10px 0;text-align:center;display:none;">
                            <div style="color:#888;font-size:12px;">예상 공격력</div>
                            <div id="synth-atk-preview" style="color:#e74c3c;font-size:18px;font-weight:bold;">+?? ~ +??
                            </div>
                        </div>

                        <div style="text-align:center;">
                            <span style="color:#888;">비용: </span>
                            <span id="synth-cost" style="color:#f1c40f;">0G</span>
                        </div>

                        <div id="synth-weapon-list" class="weapon-select-grid" style="margin-top:15px;">
                            <!-- 무기 목록 -->
                        </div>

                        <button class="btn-small" id="synth-btn" style="width:100%;margin-top:15px;background:#e67e22;"
                            onclick="game.doSynthesis()" disabled>
                            합성하기
                        </button>
                    </div>

                    <!-- 강화 탭 -->
                    <div id="smith-enhance-tab" style="display:none;">
                        <p style="text-align:center;color:#888;font-size:13px;">무기를 강화하여 공격력을 높이세요 (+1 ~ +10)</p>

                        <div class="enhance-weapon-display">
                            <div id="enhance-weapon-icon" style="font-size:60px;">🗡️</div>
                            <div id="enhance-weapon-name" style="font-size:18px;font-weight:bold;margin:10px 0;">무기를
                                선택하세요
                            </div>
                            <div id="enhance-weapon-level" style="color:#f39c12;font-size:20px;"></div>
                        </div>

                        <div class="enhance-info">
                            <div class="enhance-stat">
                                <div style="color:#888;">성공률</div>
                                <div class="enhance-stat-value enhance-success" id="enhance-rate">-</div>
                            </div>
                            <div class="enhance-stat">
                                <div style="color:#888;">비용</div>
                                <div class="enhance-stat-value" id="enhance-cost" style="color:#f1c40f;">-</div>
                            </div>
                            <div class="enhance-stat">
                                <div style="color:#888;">실패 시</div>
                                <div class="enhance-stat-value enhance-warning" id="enhance-fail">-1</div>
                            </div>
                        </div>

                        <!-- 강화 능력치 미리보기 -->
                        <div id="enhance-preview"
                            style="background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;margin:10px 0;text-align:center;display:none;">
                            <div style="color:#888;font-size:12px;">공격력 변화</div>
                            <div style="display:flex;justify-content:center;align-items:center;gap:10px;">
                                <span id="enhance-atk-current" style="color:#888;font-size:16px;">+0</span>
                                <span style="color:#27ae60;">→</span>
                                <span id="enhance-atk-after"
                                    style="color:#27ae60;font-size:18px;font-weight:bold;">+0</span>
                                <span id="enhance-atk-diff" style="color:#f39c12;font-size:12px;">(+0)</span>
                            </div>
                        </div>

                        <div id="enhance-weapon-list" class="weapon-select-grid">
                            <!-- 무기 목록 -->
                        </div>

                        <button class="btn-small" id="enhance-btn"
                            style="width:100%;margin-top:15px;background:#3498db;" onclick="game.doEnhance()" disabled>
                            강화하기
                        </button>
                    </div>

                    <button class="btn-small" style="width:100%;margin-top:15px;"
                        onclick="game.closeSmith()">닫기</button>
                </div>
            </div>
        </div>

        <!-- Duplicates removed -->

        <div id="ui-panel">
            <div class="ui-panel-content">
                <!-- Player Info -->
                <div class="player-info">
                    <div class="level-hp">
                        <span>Lv.<span id="ui-lv">1</span></span>
                        <span style="color:#e74c3c">♥ <span id="ui-hp">100</span>/<span id="ui-maxhp">100</span></span>
                    </div>
                    <div class="exp-bar-container">
                        <div id="exp-bar-fill" style="width:0%;height:100%;background:#3498db;transition:width 0.3s;">
                        </div>
                    </div>
                    <div class="exp-text">EXP <span id="ui-exp">0</span> / <span id="ui-maxexp">100</span></div>
                </div>

                <!-- Weapon & Currency -->
                <div class="weapon-info">
                    <div class="weapon-name">
                        <span id="ui-weapon-icon">🗡️</span>
                        <span id="ui-weapon">Wooden Sword</span>
                    </div>
                    <div class="currency">
                        <span style="color:#f1c40f">💰 <span id="ui-gold">0</span></span>
                        <span style="color:#3498db">💎 <span id="ui-diamond">0</span></span>
                    </div>
                </div>

                <!-- Menu Buttons -->
                <div class="menu-grid">
                    <button class="btn-menu" onclick="game.openShop()">상점</button>
                    <button class="btn-menu" onclick="game.openGacha()">뽑기</button>
                    <button class="btn-menu" onclick="game.openInventory()">가방</button>
                    <button class="btn-menu" onclick="game.openSmith()">강화</button>
                    <button class="btn-menu" onclick="game.openSmith()">강화</button>
                    <button class="btn-menu" id="btn-open-stat" onclick="game.openStatPanel()"
                        style="position:relative;">
                        스탯<div id="stat-noti" class="notification-dot"></div>
                    </button>
                    <button class="btn-menu" onclick="game.openSettings()">설정</button>
                </div>
            </div>
        </div>

        <!-- Stat Panel Removed (Refactored to Modal) -->
    </div><!-- end game-scaler -->

    <script>
        // ===== VIEWPORT SCALING SYSTEM =====
        // Responsive Full-Screen Mode - Game fills entire window
        function updateViewportScale() {
            // No scaling transform needed - CSS handles 100% width/height
            // This function is kept for potential future use or debugging
            console.log(`📐 Viewport: ${window.innerWidth}x${window.innerHeight}`);
        }

        // Apply on load and resize
        window.addEventListener('resize', updateViewportScale);
        window.addEventListener('load', updateViewportScale);
        document.addEventListener('DOMContentLoaded', updateViewportScale);

        // Module Removed for file:// compatibility
        // import * as THREE from 'three';
        // import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Globals for HTML access
        // window.THREE = THREE; 

        // 숫자 포맷터
        const NumFormat = {
            suffixes: ['', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc'],
            format(num) {
                if (num === null || num === undefined || isNaN(num)) return '0';
                if (num < 0) return '-' + this.format(-num);
                if (num < 1000) return Math.floor(num).toString();
                const tier = Math.floor(Math.log10(Math.abs(num)) / 3);
                if (tier >= this.suffixes.length) {
                    const exp = tier * 3;
                    return (num / Math.pow(10, exp)).toFixed(2) + 'e' + exp;
                }
                const suffix = this.suffixes[tier];
                const scale = Math.pow(10, tier * 3);
                const scaled = num / scale;
                if (scaled >= 100) return Math.floor(scaled) + suffix;
                else if (scaled >= 10) return scaled.toFixed(1).replace(/\.0$/, '') + suffix;
                else return scaled.toFixed(2).replace(/\.?0+$/, '') + suffix;
            },
            percent(num, decimals = 0) {
                return num >= 1000 ? this.format(num) + '%' : num.toFixed(decimals) + '%';
            }
        };

        // 기본 설정 (JSON에서 로드됨)
        let DEFAULT_CONFIG = null;
        let GAME_CONFIG = null;

        // 폴백 데이터 (CORS 오류 시 사용)
        const FALLBACK_DATA = {
            weapons: [
                { id: 0, name: "맨주먹", baseAtk: 0, grade: "common", price: 0, icon: "👊" },
                { id: 1, name: "목검", baseAtk: 5, grade: "common", price: 100, icon: "assets/weapons/wooden_sword.png" },
                { id: 2, name: "철검", baseAtk: 15, grade: "common", price: 500, icon: "assets/weapons/iron_sword.png" },
                { id: 3, name: "황금도끼", baseAtk: 30, grade: "uncommon", price: 1500, icon: "assets/weapons/golden_axe.png" },
                { id: 4, name: "카타나", baseAtk: 45, grade: "uncommon", price: 3000, icon: "assets/weapons/katana.png" },
                { id: 5, name: "마법 지팡이", baseAtk: 55, grade: "rare", price: 5000, icon: "assets/weapons/magic_staff.png" },
                { id: 6, name: "레이저검", baseAtk: 70, grade: "rare", price: 8000, icon: "assets/weapons/laser_sword.png" },
                { id: 7, name: "엑스칼리버", baseAtk: 100, grade: "epic", price: 15000, icon: "assets/weapons/excalibur.png" },
                { id: 8, name: "용살자", baseAtk: 150, grade: "legendary", price: 0, icon: "assets/weapons/dragon_slayer.png" },
                // New weapons added for completeness if game logic supports dynamic IDs, 
                // otherwise updating existing ones was priority. user requested GENESIS etc.
                // Assuming they might be added dynamically or just ensuring assets exist.
                // Since I cannot change the ID logic blindly, I will leave existing IDs but ensure their icons match if names match.
                // Wait, user asked to "generate images", and I did. 
                // I should probably ADD them if they aren't there, or REPLACE.
                // The prompt was "generate images for...".
                // I'll stick to updating existing matches and adding new ones if appropriate, 
                // but checking the list, 'Dragon Slayer' (id 8) is there. 'Excalibur' (id 7) is there.
                // 'Genesis', 'Holy Sword', 'Mjolnir', etc are NOT in this list. 
                // I will append them to the list so they are available in game.
                { id: 9, name: "악마의 낫", baseAtk: 200, grade: "epic", price: 20000, icon: "assets/weapons/demon_scythe.png" },
                { id: 10, name: "드래곤 팡", baseAtk: 250, grade: "legendary", price: 0, icon: "assets/weapons/dragon_fang.png" },
                { id: 11, name: "제네시스", baseAtk: 300, grade: "legendary", price: 0, icon: "assets/weapons/genesis.png" },
                { id: 12, name: "홀리 소드", baseAtk: 350, grade: "legendary", price: 0, icon: "assets/weapons/holy_sword.png" },
                { id: 13, name: "묠니르", baseAtk: 400, grade: "legendary", price: 0, icon: "assets/weapons/mjolnir.png" },
                { id: 14, name: "피닉스 블레이드", baseAtk: 450, grade: "legendary", price: 0, icon: "assets/weapons/phoenix_blade.png" },
                { id: 15, name: "라그나로크", baseAtk: 500, grade: "legendary", price: 0, icon: "assets/weapons/ragnarok.png" }
            ],
            grades: {
                common: { name: "일반", color: "#9e9e9e", multiplier: 1.0 },
                uncommon: { name: "고급", color: "#4caf50", multiplier: 1.5 },
                rare: { name: "레어", color: "#2196f3", multiplier: 2.0 },
                epic: { name: "에픽", color: "#9c27b0", multiplier: 3.0 },
                legendary: { name: "전설", color: "#ff9800", multiplier: 5.0 }
            },
            gacha: {
                goldCost: 500,
                diamondCost: 100,
                tenPullCost: 900,
                rates: { common: 50, uncommon: 30, rare: 15, epic: 4, legendary: 1 },
                pity: { epic: 50, legendary: 100 }
            },
            monsters: [
                { id: 0, name: "슬라임", hp: 30, atk: 5, def: 0, aspd: 0.8, exp: 10, gold: 15, icon: "assets/monsters/slime.png" },
                { id: 1, name: "고블린", hp: 50, atk: 8, def: 2, aspd: 1.0, exp: 20, gold: 25, icon: "assets/monsters/goblin.png" },
                { id: 2, name: "늑대", hp: 45, atk: 10, def: 1, aspd: 1.3, exp: 18, gold: 20, icon: "assets/monsters/wolf.png" },
                { id: 3, name: "오크", hp: 80, atk: 12, def: 5, aspd: 0.7, exp: 35, gold: 40, icon: "assets/monsters/orc.png" },
                { id: 4, name: "스켈레톤", hp: 60, atk: 15, def: 3, aspd: 1.2, exp: 30, gold: 30, icon: "assets/monsters/skeleton.png" },
                { id: 5, name: "흑기사", hp: 120, atk: 20, def: 8, aspd: 0.8, exp: 60, gold: 70, icon: "assets/monsters/dark_knight.png" },
                { id: 6, name: "악마", hp: 100, atk: 22, def: 6, aspd: 0.9, exp: 55, gold: 60, icon: "assets/monsters/demon.png" },
                { id: 7, name: "드래곤", hp: 200, atk: 30, def: 12, aspd: 0.6, exp: 150, gold: 150, icon: "assets/monsters/dragon.png" }
            ],
            backgrounds: [
                { id: 2, name: "천장", val: "#050505" }
            ],
            gameSettings: {
                themeChangeInterval: 1,
                battleDelayMultiplier: 0.5
            }
        };

        // 데이터 로더
        const DataLoader = {
            async loadJSON(path) {
                // Offline/Local check: Skip fetch and use FALLBACK_DATA immediately on file protocol
                if (location.protocol === 'file:') {
                    console.warn('📂 File protocol detected. Skipping fetch for:', path);
                    return null;
                }
                try {
                    const response = await fetch(path);
                    if (!response.ok) throw new Error(`Failed to load ${path}`);
                    return await response.json();
                } catch (e) {
                    console.warn(`⚠️ Error loading ${path}, using fallback`, e.message);
                    return null;
                }
            },
            async loadAll() {
                const [monstersData, weaponsData, configData] = await Promise.all([
                    this.loadJSON('data/monsters.json'),
                    this.loadJSON('data/weapons.json'),
                    this.loadJSON('data/config.json')
                ]);

                // JSON 로드 성공 여부 확인
                const jsonLoaded = monstersData && weaponsData;

                if (jsonLoaded) {
                    // JSON에서 로드
                    DEFAULT_CONFIG = {
                        weapons: weaponsData.weapons.map((w, i) => ({
                            id: i, name: w.name, val: w.atk, price: w.price || 0, icon: w.icon
                        })),
                        // Fix: monsters.json is an array, not { monsters: [...] }
                        monsters: Array.isArray(monstersData) ? monstersData : monstersData.monsters,
                        backgrounds: [
                            { id: 0, name: "벽", val: configData?.backgrounds?.wall || "assets/textures/wall.png" },
                            { id: 1, name: "바닥", val: configData?.backgrounds?.floor || "assets/textures/floor.png" },
                            { id: 2, name: "천장", val: configData?.backgrounds?.ceiling || "#050505" }
                        ]
                    };
                    GAME_CONFIG = configData;
                    console.log('📦 JSON Data loaded:', {
                        monsters: DEFAULT_CONFIG.monsters ? DEFAULT_CONFIG.monsters.length : 0,
                        weapons: DEFAULT_CONFIG.weapons ? DEFAULT_CONFIG.weapons.length : 0
                    });
                } else {
                    // 폴백 데이터 사용
                    DEFAULT_CONFIG = JSON.parse(JSON.stringify(FALLBACK_DATA));
                    console.log('📦 Using FALLBACK data (CORS/file:// issue)');
                }

                return DEFAULT_CONFIG;
            }
        };

        window.settings = {
            data: null,
            async init() {
                // JSON에서 로드
                await DataLoader.loadAll();
                const saved = localStorage.getItem('wm_v22');
                this.data = saved ? JSON.parse(saved) : JSON.parse(JSON.stringify(DEFAULT_CONFIG));
            },
            open() {
                document.getElementById('settings-overlay').style.display = 'flex';
                this.renderInputs();
                if (game) {
                    document.getElementById('opt-autosave').checked = game.autoSave;
                    document.getElementById('opt-dmgtext').checked = game.showDamageText;

                    // Slot Switcher UI
                    if (game && game.updateSettingsSlotUI) {
                        game.updateSettingsSlotUI();
                    }
                }
            },
            close() { document.getElementById('settings-overlay').style.display = 'none'; },
            renderInputs() {
                const render = (arr, cid, key) => {
                    const c = document.getElementById(cid);
                    c.innerHTML = '';
                    arr.forEach((it, i) => {
                        const v = it[key];
                        const isUrl = v.indexOf('http') === 0 || v.indexOf('data:') === 0 || v.indexOf('assets/') === 0;
                        c.innerHTML += `<div class="res-row"><div class="res-label">${it.name}</div><input type="text" class="res-input" id="inp-${cid}-${i}" value="${v}"><div class="res-preview">${isUrl ? `<img src="${v}">` : v}</div></div>`;
                    });
                };
                render(this.data.weapons, 'set-weapons', 'icon');
                render(this.data.monsters, 'set-monsters', 'icon');
                render(this.data.backgrounds, 'set-backgrounds', 'val');
            },
            save() {
                const save = (arr, cid, key) => arr.forEach((it, i) => { it[key] = document.getElementById(`inp-${cid}-${i}`).value; });
                save(this.data.weapons, 'set-weapons', 'icon');
                save(this.data.monsters, 'set-monsters', 'icon');
                save(this.data.backgrounds, 'set-backgrounds', 'val');
                localStorage.setItem('wm_v22', JSON.stringify(this.data));
                if (game) {
                    game.log('💾 설정이 저장되었습니다.');
                    game.reload();
                }
                this.close();
            },
            async reset() {
                if (game && await game.showConfirmModal('설정 초기화', '모든 커스텀 설정을 초기화하시겠습니까?')) {
                    localStorage.removeItem('wm_v22');
                    this.data = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
                    this.renderInputs();
                    game.log('⚙️ 설정이 초기화되었습니다.');
                    game.reload();
                }
            }
        };

        const GAME_PRICES = {
            slotUnlock: 1000,
            gacha: { single: 100, ten: 900 },
            potion: 50,
            upgrade: { base: 100, growth: 1.1 },
            aspd: { base: 150, growth: 1.1 },
            critRate: { base: 200, growth: 1.1 },
            critDmg: { base: 250, growth: 1.1 },
            speedDiamond: [0, 500, 2000], // cumulative costs for tier 1, 2
            speedGold: [1000, 2000, 4000, 8000, 16000]
        };

        const SharedData = {
            get() {
                const s = localStorage.getItem('wm_shared');
                return s ? JSON.parse(s) : { diamond: 1000, unlockedSlots: [1] };
            },
            save(data) {
                localStorage.setItem('wm_shared', JSON.stringify(data));
            },
            getDiamond() { return this.get().diamond; },
            setDiamond(v) {
                const d = this.get();
                d.diamond = v;
                this.save(d);
            },
            isSlotUnlocked(id) {
                return (this.get().unlockedSlots || [1]).includes(id);
            },
            unlockSlot(id) {
                const d = this.get();
                if (!d.unlockedSlots) d.unlockedSlots = [1];
                if (!d.unlockedSlots.includes(id)) {
                    d.unlockedSlots.push(id);
                    this.save(d);
                }
            }
        };

        // Phase 6: Game Balance Constants (Centralized)
        const GameBalance = {
            baseHp: 100,
            baseAtk: 5,
            baseGold: 20,
            baseExp: 15,
            stageGrowth: 2.1,
            waveGrowth: 1.1,
            bossStatMult: 5,
            bossWaveInterval: 10
        };

        // Enable Texture Caching for Performance
        THREE.Cache.enabled = true;


        class Game {
            // 밸런스 테스트를 위한 강제 초기화 (한 번만 실행되도록 플래그 처리 권장하지만, 사용자 요청에 따라 매번 리셋될 수 있음 - 주의)
            // 사용자가 "캐릭터 모두 리셋"을 요청했으므로 이 세션에서는 생성자에서 리셋을 수행.
            // 실제 상용 배포시에는 제거해야 함.
            constructor() {
                this.slotId = 1;
                this.allies = [];
                // Fix: Assign initialized resources
                this.r = settings.data || DEFAULT_CONFIG;

                this.baseStats = { atk: 10, maxHp: 100, aspd: 1.0, critRate: 5, critDmg: 150 };
                // 스탯 포인트 투자 횟수
                this.invested = { atk: 0, maxHp: 0, aspd: 0, critRate: 0, critDmg: 0 };
                // 골드 강화 횟수 (새로 추가됨)
                this.purchased = { atk: 0, maxHp: 0, aspd: 0, critRate: 0, critDmg: 0 };

                this.statPerPoint = { atk: 2, maxHp: 10, aspd: 0.02, critRate: 0.5, critDmg: 5 };
                // 골드 강화 당 증가량
                this.goldUpgradeStats = { atk: 5, maxHp: 50, aspd: 0.05, critRate: 0.5, critDmg: 5 };

                this.p = {
                    hp: 100, maxHp: 100, atk: 10, aspd: 1.0, critRate: 5, critDmg: 150,
                    atkRaw: 10, maxHpRaw: 100, aspdRaw: 1.0, critRateRaw: 5, critDmgRaw: 150,
                    gold: 0, diamond: 1000, lv: 1, exp: 0, maxExp: 100, wIdx: 0, statPoints: 5, pityCount: 0,
                    invested: { atk: 0, maxHp: 0, aspd: 0, critRate: 0, critDmg: 0 },
                    purchased: { atk: 0, maxHp: 0, aspd: 0, critRate: 0, critDmg: 0 },
                    inventory: [],
                    equippedWeapon: null,
                    speedDiamondTier: 0,
                    speedGoldLevel: 0
                };
                this.stage = 1;
                this.state = 'IDLE';
                this.e = null;
                this.autoSave = true;
                this.showDamageText = true;

                // Wave system (10 waves per stage)
                this.wave = 1;
                this.maxWaves = 10;
                this.currentEnemy = null; // Track current enemy for display

                // 월드 & 보스 시스템
                this.stagesPerWorld = 100;
                this.bossInterval = 10;
                this.worldThemes = [
                    { name: "던전", hue: 0 },
                    { name: "숲", hue: 90 },
                    { name: "용암동굴", hue: 20 },
                    { name: "얼음성", hue: 200 },
                    { name: "마왕성", hue: 280 }
                ];

                // Initialize Slot Screen
                setTimeout(() => this.renderSlotScreen(), 100);
            }

            // --- Slot & Party System ---

            renderSlotScreen() {
                const screen = document.getElementById('slot-select-screen');
                const startScreen = document.getElementById('start-screen');
                if (screen) screen.style.display = 'flex';
                if (startScreen) startScreen.style.display = 'none';

                // Update shared diamond display on slot screen if it exists, otherwise simplify
                // Ideally we show "Current Diamonds: XXX" on the slot screen.
                // Using existing slot-info blocks.

                // Use helper to render slots
                for (let i = 1; i <= 3; i++) {
                    const el = document.getElementById(`slot-${i}-card`);
                    if (el) el.innerHTML = this.getSlotCardHTML(i);
                }
            }

            closeSlotScreen() {
                const screen = document.getElementById('slot-select-screen');
                const startScreen = document.getElementById('start-screen');
                if (screen) screen.style.display = 'none';
                if (startScreen) startScreen.style.display = 'flex';
            }

            getSlotCardHTML(id, isSettings = false) {
                const isUnlocked = SharedData.isSlotUnlocked(id);
                if (!isUnlocked) {
                    return `
                        <div class="slot-card locked" onclick="game.selectSlot(${id}, ${isSettings})">
                            <div class="slot-icon">🔒</div>
                            <div class="slot-title">Slot ${id}</div>
                            <div class="slot-status">Locked</div>
                            <div class="slot-price">${NumFormat.format(GAME_PRICES.slotUnlock)} 💎</div>
                        </div>
                    `;
                }

                const data = localStorage.getItem(`save_slot_${id}`);
                if (data) {
                    try {
                        const parsed = JSON.parse(data);
                        const wName = parsed.p.equippedWeapon?.name || "맨주먹";
                        const dateStr = parsed.savedAt ? new Date(parsed.savedAt).toLocaleString() : 'No Date';

                        // Active slot highlight (if used in settings)
                        const isActive = this.slotId === id;
                        const activeStyle = isActive ? 'border: 2px solid #2ecc71; box-shadow: 0 0 10px #2ecc71;' : '';

                        return `
                            <div class="slot-card" style="${activeStyle}" onclick="game.selectSlot(${id}, ${isSettings})">
                                <div class="slot-header">
                                    <span class="slot-lv">Lv.${parsed.p.lv}</span>
                                    <span class="slot-title">Slot ${id}</span>
                                </div>
                                <div class="slot-detail">Stage ${parsed.stage}</div>
                                <div class="slot-detail" style="color:#aaa">${wName}</div>
                                <div class="slot-time">${dateStr}</div>
                            </div>
                        `;
                    } catch (e) { return `<div class="slot-card error">Corrupted</div>`; }
                } else {
                    return `
                        <div class="slot-card empty" onclick="game.selectSlot(${id}, ${isSettings})">
                            <div class="slot-icon">➕</div>
                            <div class="slot-title">Slot ${id}</div>
                            <div class="slot-status">New Game</div>
                        </div>
                    `;
                }
            }

            // Modified to handle Settings context (forceLoad=true switches immediately)
            async selectSlot(id, forceLoad = false) {
                if (!SharedData.isSlotUnlocked(id)) {
                    const diamonds = SharedData.getDiamond();
                    const price = GAME_PRICES.slotUnlock;
                    if (await this.showConfirmModal('슬롯 잠금 해제', `다이아 ${price}개를 사용하여 슬롯 ${id}을(를) 해제하시겠습니까?\n(보유: ${diamonds})`)) {
                        if (diamonds >= price) {
                            SharedData.setDiamond(diamonds - price);
                            SharedData.unlockSlot(id);
                            this.renderSlotScreen();
                            this.updateSettingsSlotUI(); // Update settings too if open
                            this.log(`🔓 슬롯 ${id} 해제 완료!`);
                        } else {
                            await this.showConfirmModal('알림', '다이아가 부족합니다.', [{ text: '확인', value: true }]);
                        }
                    }
                    return;
                }

                if (forceLoad) {
                    // Check if clicking current slot
                    if (this.slotId === id) return;

                    if (await this.showConfirmModal('캐릭터 변경', `슬롯 ${id}로 변경하시겠습니까?`)) {
                        this.switchSlot(id);
                    }
                    return;
                }

                this.slotId = id;
                document.getElementById('slot-select-screen').style.display = 'none';
                // Direct Entry: Bypass Start Screen
                // document.getElementById('start-screen').style.display = 'flex';
                this.load();
                this.start();
            }

            updateSettingsSlotUI() {
                const container = document.getElementById('slot-container');
                if (!container) return;
                container.innerHTML = '';
                container.style.display = 'grid';
                container.style.gridTemplateColumns = 'repeat(3, 1fr)';
                container.style.gap = '10px';

                for (let i = 1; i <= 3; i++) {
                    const div = document.createElement('div');
                    // Pass true for isSettings to enable switch behavior
                    div.innerHTML = this.getSlotCardHTML(i, true);
                    container.appendChild(div.firstElementChild); // Extract from wrapper
                }
            }

            switchSlot(id) {
                this.saveProgress();
                this.allies = [];
                if (window.game3d) {
                    Object.keys(window.game3d.allyMeshes).forEach(k => window.game3d.removeAlly(k));
                }

                this.slotId = id;
                this.load();

                // Reset World State for Clean Transition
                document.getElementById('enemy-container').style.display = 'none';
                this.e = null;
                this.state = 'IDLE';

                this.log(`🔄 슬롯 ${id}로 변경되었습니다.`);

                // UX: Close settings/slots after switch so user is in game
                if (settings && settings.close) settings.close();
                this.closeSlotScreen();

                this.walk();
            }

            renderPartyUI() {
                // Determine other slots based on current slotId
                const others = [1, 2, 3].filter(id => id !== this.slotId);

                // Update buttons for the other two slots
                this.updatePartySlot(document.getElementById('ally-slot-left'), others[0]);
                this.updatePartySlot(document.getElementById('ally-slot-right'), others[1]);
            }

            updatePartySlot(el, targetSlotId) {
                if (!el) return;
                // Cannot summon self or Invalid slot
                if (this.slotId === targetSlotId) {
                    el.style.display = 'none';
                    return;
                }

                // Ensure default display is flex if not hidden
                el.style.display = 'flex';

                const allyIdx = this.allies.findIndex(a => a.slotId === targetSlotId);
                const isSummoned = allyIdx >= 0;

                if (isSummoned) {
                    // Already summoned
                    el.innerHTML = `<div style="font-size:20px;">❌</div><div style="font-size:10px;">Dismiss</div>`;
                    el.onclick = () => this.removeAlly(targetSlotId);
                    el.style.borderColor = '#e74c3c';
                } else {
                    // Check logic: Unlocked? Save exists?
                    const isUnlocked = SharedData.isSlotUnlocked(targetSlotId);
                    const save = localStorage.getItem(`save_slot_${targetSlotId}`);

                    if (!isUnlocked) {
                        el.innerHTML = `<div style="font-size:20px;">🔒</div><div style="font-size:10px;">Locked</div>`;
                        el.onclick = () => this.showConfirmModal('알림', `슬롯 ${targetSlotId}이(가) 잠겨있습니다.\n메인 화면에서 해제할 수 있습니다.`, [{ text: '확인', value: true }]);
                        el.style.borderColor = '#7f8c8d';
                    } else if (save) {
                        el.innerHTML = `<div style="font-size:20px;">➕</div><div style="font-size:10px;">Summon</div>`;
                        el.onclick = () => this.summonAlly(targetSlotId);
                        el.style.borderColor = '#2ecc71';
                    } else {
                        el.innerHTML = `<div style="font-size:20px;">🕸️</div><div style="font-size:10px;">Empty</div>`;
                        el.onclick = async () => {
                            if (await this.showConfirmModal('빈 슬롯', `슬롯 ${targetSlotId}이(가) 비어있습니다.\n해당 슬롯으로 이동하여 캐릭터를 생성하시겠습니까?`)) {
                                this.saveProgress(); // Save current
                                location.reload(); // Simple reload to go to slot screen
                            }
                        };
                        el.style.borderColor = '#95a5a6';
                    }
                }
            }

            summonAlly(targetSlotId) {
                const save = localStorage.getItem(`save_slot_${targetSlotId}`);
                if (!save) return;
                try {
                    const data = JSON.parse(save);
                    const ally = {
                        slotId: targetSlotId,
                        name: `Slot ${targetSlotId}`,
                        lv: data.p.lv || 1,
                        atk: data.p.atk || 10,
                        aspd: data.p.aspd || 1.0,
                        critRate: data.p.critRate || 5,
                        critDmg: data.p.critDmg || 150,
                        weapon: data.p.equippedWeapon || null,
                        wIdx: data.p.wIdx || 0,
                        lastAttack: 0
                    };
                    this.allies.push(ally);
                    this.log(`🙌 Slot ${targetSlotId} Joined the party!`);
                    console.log(`[SummonAlly] Slot ${targetSlotId} Data:`, data.p);
                    console.log(`[SummonAlly] Ally Object created:`, ally);

                    if (window.game3d) window.game3d.addAlly(ally);
                    this.renderPartyUI();
                } catch (e) { console.error(e); }
            }

            removeAlly(targetSlotId) {
                const idx = this.allies.findIndex(a => a.slotId === targetSlotId);
                if (idx >= 0) {
                    this.allies.splice(idx, 1);
                    this.log(`👋 Slot ${targetSlotId} Left the party.`);

                    if (window.game3d) window.game3d.removeAlly(targetSlotId);
                    this.renderPartyUI();
                }
            }

            // 현재 월드 번호 (100웨이브 = 1월드)
            get currentWorld() {
                return Math.floor((this.stage - 1) / 100) + 1;
            }

            // 현재 UI 표시 스테이지 (1-1 ~ 1-10)
            get currentDisplayStage() {
                // 100웨이브를 10개 스테이지로 나눔 (10웨이브/스테이지)
                return Math.ceil(((this.stage - 1) % 100 + 1) / 10);
            }

            // 현재 웨이브 (1-10)
            get currentWave() {
                return (this.stage - 1) % 10 + 1;
            }

            // 보스 스테이지 여부 (매 월드 마지막, 즉 100웨이브 단위)
            get isBossStage() {
                return this.stage % 100 === 0;
            }

            // 현재 월드 테마
            get currentTheme() {
                const interval = (this.r.gameSettings && this.r.gameSettings.themeChangeInterval) ? this.r.gameSettings.themeChangeInterval : 100;
                const idx = Math.floor((this.stage - 1) / interval) % this.worldThemes.length;
                return this.worldThemes[idx];
            }

            // Update Stage Display Bar UI
            updateStageDisplay() {
                const stageDisplayText = document.getElementById('stage-display-text');
                const stageWaveInfo = document.getElementById('stage-wave-info');
                const stageMonsterName = document.getElementById('stage-monster-name');
                const stageBarEl = document.getElementById('stage-display-bar');

                // Update stage number with boss indicator
                if (stageDisplayText) {
                    const stageText = `STAGE ${this.stage}${this.isBossStage ? ' 👑 BOSS' : ''}`;
                    stageDisplayText.textContent = stageText;
                }

                // Update wave info (always show current wave)
                if (stageWaveInfo) {
                    stageWaveInfo.textContent = `Wave ${this.wave}/10`;
                }

                // Update monster name (show current enemy name)
                if (stageMonsterName && this.currentEnemy) {
                    stageMonsterName.textContent = this.currentEnemy.name || '???';
                }

                // Add boss styling
                if (stageBarEl) {
                    if (this.isBossStage) {
                        stageBarEl.classList.add('boss-stage');
                    } else {
                        stageBarEl.classList.remove('boss-stage');
                    }
                }
            }

            // 배속 계산: 다이아 배속 × (1 + 골드 보너스)
            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            getSpeedMultiplier() {
                const diamondMult = [1, 1.5, 2.0][this.p.speedDiamondTier] || 1;
                const goldBonus = this.p.speedGoldLevel * 0.05; // 0 ~ 0.25
                return diamondMult * (1 + goldBonus);
            }

            getStageTheme(stage) {
                // Configurable interval (Default: 10)
                const config = (settings.data && settings.data.config && settings.data.config.gameSettings) || {};
                const interval = config.themeChangeInterval || 10;

                // Helper to get theme by index
                // 0: Grass, 1: Cave, 2: Snow, 3: Village, 4: Castle
                const themeList = ['grass', 'cave', 'snow', 'village', 'castle'];

                // Calculate theme index based on interval
                // e.g. interval 10: 1-10 -> 0, 11-20 -> 1
                // e.g. interval 1: 1 -> 0, 2 -> 1, ... 5 -> 4, 6 -> 0 (cycle?) or 5 -> 4 (clamp?)
                // Request implied specific ranges for 10. For 1, let's Cycle them.

                let idx = Math.floor((stage - 1) / interval);

                // If interval is 1, we simply cycle through 5 themes? 
                // "1~10 Grass, 11~20 Cave" structure implies sequential progression.
                // If interval is 1, then Stage 1=Grass, Stage 2=Cave, Stage 3=Snow...
                // This seems to be the intent for "Testing".

                // Safe Modulo to cycle if it goes beyond defined themes
                idx = idx % themeList.length;

                const themeKey = themeList[idx];

                // Use data from settings if available (supports bundling)
                if (this.r && this.r.stageThemes && this.r.stageThemes[themeKey]) {
                    return this.r.stageThemes[themeKey];
                }

                return {
                    wall: `assets/textures/theme_${themeKey}_wall.png`,
                    floor: `assets/textures/theme_${themeKey}_floor.png`,
                    ceiling: `assets/textures/theme_${themeKey}_ceiling.png`
                };
            }

            reload() {
                this.r = settings.data;

                // Dynamic Background Logic
                const theme = this.getStageTheme(this.stage || 1);

                this.applyBg('.wall-left', theme.wall);
                this.applyBg('.wall-right', theme.wall);
                this.applyBg('.floor', theme.floor);
                this.applyBg('.ceiling', theme.ceiling);

                // Quality Enhancement: Update 3D Background Theme
                if (window.game3d) {
                    window.game3d.updateBackgroundTheme(this.currentTheme.name);
                }

                this.updateHand();
            }

            applyBg(sel, v) {
                document.querySelectorAll(sel).forEach(el => {
                    const isImage = v.indexOf('http') === 0 || v.indexOf('data:') === 0 || v.indexOf('assets/') === 0;
                    if (isImage) {
                        el.style.backgroundImage = `url('${v}')`;
                        el.style.backgroundColor = '';
                    } else {
                        el.style.backgroundImage = '';
                        el.style.backgroundColor = v;
                    }
                });
            }

            start() {
                // Ensure ALL overlays are hidden
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('slot-select-screen').style.display = 'none';

                this.state = 'IDLE';
                this.log("모험 시작!");
                this.updateStageDisplay(); // Update stage display on start
                this.walk();
                this.renderPartyUI(); // Ensure party buttons appear
                this.startAllyLoop(); // Start Ally Combat Loop
                this.saveProgress();
            }



            walk() {
                if (this.p.hp <= 0) { this.die(); return; }
                this.state = 'WALK';
                const speed = this.getSpeedMultiplier();
                const tunnelEl = document.querySelector('.tunnel-container');
                tunnelEl.classList.add('moving');
                // 배속과 무관하게 배경 애니메이션 속도는 고정 (어지러움 방지)
                tunnelEl.style.animationDuration = '0.5s';
                document.querySelectorAll('.moving .wall-left, .moving .wall-right, .moving .floor, .moving .ceiling').forEach(el => {
                    el.style.animationDuration = '0.5s';
                });
                document.getElementById('enemy-container').style.display = 'none';
                if (window.game3d) window.game3d.removeEnemy();
                // Base delay reduced from 2000ms to 1000ms for faster pacing
                setTimeout(() => { if (this.state === 'WALK') this.meet(); }, 1000 / speed);
            }

            meet() {
                this.state = 'BATTLE';
                document.querySelector('.tunnel-container').classList.remove('moving');

                // 월드 테마 적용 (hue-rotate) - Removed for textured themes
                // const theme = this.currentTheme;
                // document.querySelector('.tunnel-container').style.filter = `hue-rotate(${theme.hue}deg)`;
                document.querySelector('.tunnel-container').style.filter = 'none';

                // 보스 스테이지 확인
                const isBoss = this.isBossStage;

                // 몬스터 선택 (보스면 마지막 몬스터, 아니면 랜덤)
                const ml = this.r ? this.r.monsters : null;
                if (!ml || ml.length === 0) { return; }

                // 20-Stage Rotation System
                // Use (stage-1) % 20 so it cycles every 20 monsters.
                // Extended to 200 stages: 10 cycles.
                const mlLength = ml.length; // Should be 20+
                const cycle = Math.floor((this.stage - 1) / 20);
                const mapIdx = (this.stage - 1) % 20;

                // Ensure we don't go out of bounds if JSON has fewer monsters than 20
                // If ml has 20 monsters, mapIdx 0..19 works.
                // If ml has >20, we only use first 20 for this rotation logic as per request.
                // Or if ml has <20, use modulo length.
                const effectiveIdx = mapIdx % mlLength;
                const b = ml[effectiveIdx];

                // Balance Formula
                // Using Centralized GameBalance
                const BASE_HP = GameBalance.baseHp;
                const BASE_ATK = GameBalance.baseAtk;
                const BASE_GOLD = GameBalance.baseGold;
                const BASE_EXP = GameBalance.baseExp;

                // Multipliers
                const sMult = Math.pow(GameBalance.stageGrowth, this.stage - 1);
                const wMult = Math.pow(GameBalance.waveGrowth, (this.currentWave || 1) - 1);

                const totalMult = sMult * wMult;

                const bossBuff = isBoss ? GameBalance.bossStatMult : 1;

                this.e = {
                    name: b.name,
                    isBoss: isBoss,
                    maxHp: Math.floor(BASE_HP * totalMult * bossBuff),
                    hp: Math.floor(BASE_HP * totalMult * bossBuff),
                    atk: Math.floor(BASE_ATK * totalMult * bossBuff),
                    def: Math.floor((b.def || 0) + (this.stage * 2)),
                    aspd: b.aspd || 1.0,
                    exp: Math.floor(BASE_EXP * totalMult * bossBuff),
                    gold: Math.floor(BASE_GOLD * totalMult * bossBuff),
                    icon: b.icon,
                    // Store cycle for visual handling
                    cycle: cycle
                };

                // Track current enemy for stage bar display
                this.currentEnemy = this.e;
                this.updateStageDisplay();

                // UI 업데이트
                // UI 업데이트
                const em = document.getElementById('enemy-emoji');
                const im = document.getElementById('enemy-img');
                const ec = document.getElementById('enemy-container');

                // 2D Container Hidden for 3D Perspective Mode
                ec.style.display = 'none';

                // Call 3D Spawn
                if (window.game3d) {
                    window.game3d.spawnEnemy(this.e, isBoss);
                } else {
                    // Fallback if 3D not init
                    ec.style.display = 'flex';
                }

                // Logic below (isImage, etc) effectively skipped or irrelevant if 3D handled it, 
                // but we keep it inside the else block or just leave it for potential fallback?
                // For cleanliness, we can simplify given we are 100% 3D now.
                // Let's keep minimal fallback.

                const isImage = this.e.icon.indexOf('http') === 0 || this.e.icon.indexOf('data:') === 0 || this.e.icon.indexOf('assets/') === 0;
                if (!window.game3d) {
                    if (isImage) {
                        em.style.display = 'none';
                        im.style.display = 'block';
                        im.src = this.e.icon;
                        im.style.transform = isBoss ? 'scale(1.5)' : 'scale(1)';
                        const hueVal = (this.e.cycle * 45) % 360;
                        im.style.filter = isBoss ? `drop-shadow(0 0 30px gold) hue-rotate(${hueVal}deg)` : `drop-shadow(0 0 20px rgba(255,0,0,0.5)) hue-rotate(${hueVal}deg)`;
                        im.style.animation = 'none';
                        im.offsetHeight;
                        im.style.animation = 'enemyApproach 0.5s ease-out forwards';
                    } else {
                        im.style.display = 'none';
                        em.style.display = 'block';
                        em.innerText = this.e.icon;
                    }
                }

                // Legacy hud-name/hud-stage removed (Phase 7) - now using top bar
                // document.getElementById('hud-name').innerText = this.e.name;
                let stageText = `${this.currentWorld}-${this.currentDisplayStage}`;
                if (this.isBossStage) {
                    stageText += " Boss Stage";
                } else {
                    stageText += ` Wave ${this.currentWave}/10`;
                }
                // document.getElementById('hud-stage').innerText = stageText;

                this.updateEHp();

                if (isBoss) {
                    this.log(`🔥 보스 등장! ${this.e.name}`);
                    this.showBossMessage();
                } else {
                    this.log(`❗ ${this.e.name} 등장!`);
                }

                const speed = this.getSpeedMultiplier();
                const attackDelay = 1000 / this.p.aspd / speed;

                // Start Battle Loop after animation (500ms)
                // Applying speed to start delay too? Maybe, but animation is fixed 0.5s CSS.
                // Actually, if 4x speed, we want to start faster.
                // Let's use 500 / speed.
                // Start Battle Loop after animation (500ms * delayMult)
                const config = (settings.data && settings.data.config && settings.data.config.gameSettings) || {};
                const delayMult = config.battleDelayMultiplier || 1.0;

                setTimeout(() => this.round(), (500 * delayMult) / speed);
            }

            battleLoop() {
                // Ensure state is BATTLE
                if (this.state.trim() !== 'BATTLE') return;
                // Start the round immediately
                this.round();
            }

            startAllyLoop() {
                if (this.allyLoopId) cancelAnimationFrame(this.allyLoopId);
                console.log("[startAllyLoop] Starting independent ally loop.");
                const loop = () => {
                    if (this.state === 'BATTLE' && this.e && this.e.hp > 0) {
                        this.processAllies();
                    }
                    this.allyLoopId = requestAnimationFrame(loop);
                };
                loop();
            }

            showBossMessage() {
                // 보스 스테이지 메시지 표시
                const msg = document.createElement('div');
                msg.innerHTML = '⚔️ 보스 스테이지! ⚔️';
                msg.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%) scale(0);
                    font-size: 48px;
                    font-weight: bold;
                    color: #f1c40f;
                    text-shadow: 0 0 20px #e74c3c, 0 0 40px #c0392b;
                    z-index: 9999;
                    pointer-events: none;
                    animation: bossAppear 1.5s ease-out forwards;
                `;
                document.body.appendChild(msg);

                // CSS 애니메이션 추가
                if (!document.getElementById('boss-anim-style')) {
                    const style = document.createElement('style');
                    style.id = 'boss-anim-style';
                    style.textContent = `
                        @keyframes bossAppear {
                            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
                            30% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
                            50% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                // 자동 제거
                setTimeout(() => msg.remove(), 1500);
            }

            async round() {
                if (this.state !== 'BATTLE') return;

                this.atk(true); // Main Player Attack
                // this.processAllies(); // Ally Logic moved to independent loop

                const speed = this.getSpeedMultiplier();
                const config = (settings.data && settings.data.config && settings.data.config.gameSettings) || {};
                const delayMult = config.battleDelayMultiplier || 1.0;

                if (this.e.hp <= 0) { setTimeout(() => this.win(), (500 * delayMult) / speed); return; }

                let attackDelay = 1000 / (this.p.aspd || 1) / speed;
                // Safety Clamp: Min 20ms, Max 5000ms to prevent stall or freeze
                if (attackDelay < 20) attackDelay = 20;
                if (attackDelay > 5000) attackDelay = 5000;
                if (isNaN(attackDelay)) attackDelay = 1000;

                await this.wait(attackDelay * 0.6);
                if (this.state === 'BATTLE') {
                    this.atk(false); // Enemy Attack
                    if (this.p.hp <= 0) this.die();
                    else setTimeout(() => this.round(), attackDelay * 0.4);
                }
            }

            processAllies() {
                const now = Date.now();
                this.allies.forEach(ally => {
                    // Ensure lastAttack is initialized
                    if (!ally.lastAttack) ally.lastAttack = 0;

                    const aspd = ally.aspd || 1.0;
                    if (now - ally.lastAttack >= (1000 / aspd)) {
                        ally.lastAttack = now;
                        // DMG Calc: (Base + Stat Points) + Weapon Attack
                        const baseAndStatAtk = ally.atk || 10;
                        const wAtk = this.getWeaponAtk(ally.weapon || this.r.weapons[0]);
                        let dmg = baseAndStatAtk + wAtk;

                        let isCrit = Math.random() * 100 < (ally.critRate || 5);
                        if (isCrit) dmg *= ((ally.critDmg || 150) / 100);

                        const finalDmg = Math.floor(dmg);

                        // Apply Damage (FIX: Previously missing)
                        if (this.e && this.e.hp > 0) {
                            const def = this.e.def || 0;
                            const realDmg = Math.max(1, finalDmg - def);
                            this.e.hp = Math.max(0, this.e.hp - realDmg);

                            // Update enemy HP bar
                            this.updateEHp();

                            // Visual
                            if (window.game3d) {
                                window.game3d.triggerAllyAttack(ally.slotId);
                                const pos = window.game3d.getAllyScreenPosition(ally.slotId);
                                this.showDmg(realDmg, isCrit, false, true, pos);
                            } else {
                                this.showDmg(realDmg, isCrit, false, true);
                            }
                        }
                    }
                });
            }

            atk(isP) {
                // console.log("ATK() called. isP:", isP);
                const speed = this.getSpeedMultiplier();
                if (isP) {
                    const h = document.getElementById('right-hand');
                    h.classList.add('attack-anim');
                    setTimeout(() => h.classList.remove('attack-anim'), 200 / speed);
                    const w = this.r.weapons[this.p.wIdx];
                    let d = this.p.atk + this.getWeaponAtk(w);
                    d = Math.max(1, d - Math.floor(this.e.def * 0.5));
                    let isCrit = Math.random() * 100 < this.p.critRate;
                    if (isCrit) d = Math.floor(d * (this.p.critDmg / 100));

                    this.e.hp = Math.max(0, this.e.hp - d);
                    this.updateEHp();
                    this.showDmg(d, isCrit, false);
                    this.log(`⚔️ 공격! ${NumFormat.format(d)} 피해${isCrit ? ' (치명타!)' : ''}`);

                    // Phase 6: Visual Polish (Shake & Flash)
                    if (window.game3d) {
                        window.game3d.shakeCamera(isCrit ? 0.4 : 0.1);
                    }
                    const ei = document.getElementById('enemy-img');
                    if (ei) {
                        ei.classList.remove('hit-flash');
                        void ei.offsetWidth; // Trigger Reflow
                        ei.classList.add('hit-flash');
                    }
                    // Audio Hook
                    if (AudioManager) AudioManager.playSfx('hit');

                } else {
                    const g = document.getElementById('game-container');
                    g.classList.add('shake');
                    setTimeout(() => g.classList.remove('shake'), 300);

                    // 3D Shake on Hit
                    if (window.game3d) window.game3d.shakeCamera(0.3);

                    let d = this.e.atk;
                    this.p.hp = Math.max(0, this.p.hp - d);
                    this.updateUI();
                    this.showDmg(d, false, true);
                    this.log(`🛡️ 피격! -${NumFormat.format(d)} HP`);
                }
            }

            win() {
                // 보스 처치 시 다이아 보상
                if (this.e.isBoss) {
                    const diamondReward = 5 + this.currentWorld * 5; // 월드당 +5
                    this.p.diamond += diamondReward;
                    this.log(`🏆 보스 처치! +${NumFormat.format(this.e.exp)}EXP +${NumFormat.format(this.e.gold)}G +${diamondReward}💎`);
                } else {
                    this.log(`🏆 승리! +${NumFormat.format(this.e.exp)}EXP +${NumFormat.format(this.e.gold)}G`);
                }

                this.p.gold += this.e.gold;
                this.p.exp += this.e.exp;
                if (this.p.exp >= this.p.maxExp) {
                    this.p.lv++;
                    this.p.exp = 0;
                    this.p.maxExp = Math.floor(this.p.maxExp * 1.2);
                    this.p.statPoints += 5;
                    this.p.hp = this.p.maxHp;
                    this.log(`🎉 레벨업! (Lv.${this.p.lv}) +5 스탯 포인트!`);
                    this.saveProgress(); // Save on Level Up
                }

                // Increment wave counter
                this.wave++;
                if (this.wave > this.maxWaves) {
                    this.wave = 1; // Reset wave to 1 for new stage
                    this.stage++;
                } else {
                    // Don't increment stage if still within same 10 waves
                }

                this.updateStageDisplay(); // Update stage display when advancing
                this.reload(); // Apply new stage background
                this.updateUI();
                this.saveProgress(); // Save on Stage Clear
                this.walk();
            }

            die() {
                this.log(`💀 사망했습니다... (이전 스테이지로 후퇴)`);
                this.showDeathMessage(); // 사망 연출

                // Death Penalty: Go back 10 waves (1 Stage)
                this.stage = Math.max(1, this.stage - (this.bossInterval || 10));
                this.p.hp = this.p.maxHp;

                document.getElementById('enemy-container').style.display = 'none';
                if (window.game3d) window.game3d.removeEnemy();
                this.updateUI();
                this.saveProgress(); // 자동저장
                const speed = this.getSpeedMultiplier();
                // 3000 -> 1500 (절반으로 단축)
                setTimeout(() => this.walk(), 1500 / speed);
            }

            showDeathMessage() {
                if (!document.getElementById('death-style')) {
                    const style = document.createElement('style');
                    style.id = 'death-style';
                    style.textContent = `
                        .death-overlay {
                            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                            background: radial-gradient(circle, transparent 20%, rgba(139, 0, 0, 0.2) 90%);
                            display: flex; justify-content: center; align-items: center;
                            z-index: 10000; animation: fadeIn 0.3s forwards;
                            pointer-events: none;
                        }
                        .death-text {
                            font-size: 50px; font-weight: 900; color: #c0392b;
                            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
                            animation: dropIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
                        }
                        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
                        @keyframes dropIn { 
                            0% { transform: scale(1.5); opacity: 0; } 
                            100% { transform: scale(1); opacity: 1; } 
                        }
                    `;
                    document.head.appendChild(style);
                }

                const div = document.createElement('div');
                div.className = 'death-overlay';
                div.innerHTML = '<div class="death-text">YOU DIED</div>';
                document.body.appendChild(div);

                // 1.2초 후 제거
                setTimeout(() => {
                    div.style.transition = 'opacity 0.3s';
                    div.style.opacity = '0';
                    setTimeout(() => div.remove(), 300);
                }, 1200);
            }

            // 모든 오버레이 닫기 + 스테이지 바 숨기기
            closeAllOverlays() {
                // UI 오버레이 숨김
                document.getElementById('shop-overlay').style.display = 'none';
                document.getElementById('gacha-overlay').style.display = 'none';
                document.getElementById('stat-overlay').style.display = 'none';
                document.getElementById('settings-overlay').style.display = 'none';
                document.getElementById('inventory-overlay').style.display = 'none';
                document.getElementById('smith-overlay').style.display = 'none';

                // 스테이지 정보바 & 동료 버튼 숨김 (메뉴 집중 모드)
                const stageBar = document.getElementById('stage-display-bar');
                if (stageBar) stageBar.style.display = 'none';

                document.getElementById('ally-slot-left').style.display = 'none';
                document.getElementById('ally-slot-right').style.display = 'none';
            }

            // 게임 뷰 복구 (메뉴 닫기 공통 로직)
            restoreGameView() {
                this.closeAllOverlays(); // 일단 다 닫고

                // 스테이지 바 & 동료 버튼 복구
                const stageBar = document.getElementById('stage-display-bar');
                if (stageBar) stageBar.style.display = 'flex'; // CSS flex

                document.getElementById('ally-slot-left').style.display = 'flex';
                document.getElementById('ally-slot-right').style.display = 'flex';
            }

            // 다이아 배속 구매
            openSettings() {
                this.closeAllOverlays();
                document.getElementById('settings-overlay').style.display = 'flex';
                this.updateSettingsSlotUI();
            }

            closeSettings() {
                this.restoreGameView();
            }

            updateSettingsSlotUI() {
                const container = document.getElementById('slot-container');
                if (!container) return;

                container.innerHTML = '';
                [1, 2, 3].forEach(i => {
                    const btn = document.createElement('button');
                    btn.className = 'btn-small';
                    btn.style.margin = '0 5px';
                    // Basic indication of slot
                    btn.innerText = `Slot ${i}`;
                    // Placeholder action
                    btn.onclick = () => {
                        // logic to switch slot would go here
                        console.log(`Switch to Slot ${i} requested`);
                    };
                    container.appendChild(btn);
                });
            }


            openShop() {
                this.closeAllOverlays();
                document.getElementById('shop-overlay').style.display = 'flex';
                document.getElementById('shop-gold').innerText = NumFormat.format(this.p.gold);

                // 현재 장비 표시
                this.updateShopEquipment();

                // 무기 목록 렌더링
                this.renderWeaponShop();

                // 가격 업데이트
                this.updateShopCosts();

                // 기본 탭으로 리셋
                this.switchShopTab('items');
            }

            closeShop() {
                this.restoreGameView();
            }

            updateShopEquipment() {
                const w = this.r.weapons[this.p.wIdx];
                const iconEl = document.getElementById('shop-weapon-icon');
                const isImage = w.icon && (w.icon.indexOf('http') === 0 || w.icon.indexOf('data:') === 0 || w.icon.indexOf('assets/') === 0);
                if (isImage) {
                    iconEl.innerHTML = `<img src="${w.icon}" style="width:40px;height:40px;">`;
                } else {
                    iconEl.innerText = w.icon || '👊';
                }
                const gradeInfo = this.getGradeInfo(w.grade);
                const nameEl = document.getElementById('shop-weapon-name');
                nameEl.innerText = `[${gradeInfo.name}] ${w.name}`;
                nameEl.style.color = gradeInfo.color;
                document.getElementById('shop-weapon-atk').innerText = `공격력 +${this.getWeaponAtk(w)}`;
            }

            renderWeaponShop() {
                const container = document.getElementById('shop-weapons-tab');
                container.innerHTML = '';
                this.r.weapons.forEach((w, i) => {
                    if (i === 0) return; // 맨주먹 제외
                    if (w.price === 0) return; // 뽑기 전용 제외
                    const canBuy = this.p.gold >= w.price;
                    const isImage = w.icon && (w.icon.indexOf('http') === 0 || w.icon.indexOf('data:') === 0 || w.icon.indexOf('assets/') === 0);
                    const iconHtml = isImage ? `<img src="${w.icon}" style="width:24px;height:24px;vertical-align:middle;">` : (w.icon || '🗡️');
                    const gradeInfo = this.getGradeInfo(w.grade);
                    const weaponAtk = this.getWeaponAtk(w);
                    container.innerHTML += `
                        <div class="shop-item" style="border-left:3px solid ${gradeInfo.color};display:flex;justify-content:space-between;align-items:center;">
                            <span style="color:${gradeInfo.color}">${iconHtml} [${gradeInfo.name}] ${w.name} (+${weaponAtk})</span>
                            <button class="btn-small" style="padding:5px 10px;${canBuy ? '' : 'opacity:0.5;cursor:not-allowed;'}" onclick="game.buyWeapon(${i})">${w.price}G 구매</button>
                        </div>
                    `;
                });
            }

            switchShopTab(tab) {
                document.getElementById('shop-items-tab').style.display = tab === 'items' ? 'block' : 'none';
                document.getElementById('shop-weapons-tab').style.display = tab === 'weapons' ? 'block' : 'none';
                document.getElementById('shop-speed-tab').style.display = tab === 'speed' ? 'block' : 'none';
                document.querySelectorAll('.shop-tab').forEach((btn, i) => {
                    btn.classList.toggle('active',
                        (i === 0 && tab === 'items') ||
                        (i === 1 && tab === 'weapons') ||
                        (i === 2 && tab === 'speed'));
                });
                if (tab === 'speed') this.updateSpeedShopUI();
            }

            buyWeapon(idx) {
                const w = this.r.weapons[idx];
                if (this.p.gold < w.price) {
                    this.log('💰 골드가 부족합니다!');
                    return;
                }
                if (this.p.inventory.length >= 90) {
                    this.log('⚠️ 가방이 꽉 차서 구매할 수 없습니다.');
                    return;
                }
                this.p.gold -= w.price;
                this.addToInventory({ ...w });

                // 자동 장착: 현재 무기보다 좋으면 자동 장착
                const currentAtk = this.p.equippedWeapon ? this.getWeaponAtk(this.p.equippedWeapon) : 0;
                const newAtk = this.getWeaponAtk(w);
                const newIdx = this.p.inventory.length - 1;

                if (newAtk > currentAtk) {
                    this.equipWeapon(newIdx);
                    this.log(`✨ ${w.name} 구매 및 자동 장착! (공격력 +${newAtk})`);
                } else {
                    this.log(`🗡️ ${w.name} 구매! (가방에 추가됨)`);
                }

                this.updateUI();
                this.renderWeaponShop();
                document.getElementById('shop-gold').innerText = NumFormat.format(this.p.gold);
            }

            // 배속 상점 UI 업데이트
            updateSpeedShopUI() {
                const speed = this.getSpeedMultiplier();
                document.getElementById('shop-current-speed').innerText = speed.toFixed(1) + 'x';

                // 다이아 배속 상태 업데이트
                const tier = this.p.speedDiamondTier;
                const diamond2x = document.getElementById('speed-diamond-2x');
                const diamond4x = document.getElementById('speed-diamond-4x');

                if (tier >= 1) {
                    diamond2x.innerHTML = '<span>🚀 1.5배속</span><span style="color:#27ae60">✓ 보유중</span>';
                    diamond2x.style.opacity = '0.6';
                } else {
                    diamond2x.innerHTML = '<span>🚀 1.5배속</span><span>500💎</span>';
                    diamond2x.style.opacity = '1';
                }

                if (tier >= 2) {
                    diamond4x.innerHTML = '<span>⚡ 2.0배속</span><span style="color:#27ae60">✓ 보유중</span>';
                    diamond4x.style.opacity = '0.6';
                } else {
                    // 차액 계산
                    const cost = tier === 1 ? 1500 : 2000;
                    diamond4x.innerHTML = `<span>⚡ 2.0배속</span><span>${cost}💎</span>`;
                    diamond4x.style.opacity = '1';
                }

                // 골드 배속 상태 업데이트
                const goldLevel = this.p.speedGoldLevel;
                const goldPrices = [1000, 2000, 4000, 8000, 16000];

                if (goldLevel >= 5) {
                    document.getElementById('speed-gold-level').innerText = 'Lv.5/5 (MAX)';
                    document.getElementById('speed-gold-price').innerText = '완료';
                    document.getElementById('speed-gold-upgrade').style.opacity = '0.6';
                } else {
                    document.getElementById('speed-gold-level').innerText = `Lv.${goldLevel}/5`;
                    document.getElementById('speed-gold-price').innerText = NumFormat.format(goldPrices[goldLevel]) + 'G';
                    document.getElementById('speed-gold-upgrade').style.opacity = '1';
                }
            }

            // 다이아 배속 구매
            buyDiamondSpeed(tier) {
                if (this.p.speedDiamondTier >= tier) {
                    this.log('⚡ 이미 보유 중입니다!');
                    return;
                }

                // 가격 계산 (차액제)
                const prices = GAME_PRICES.speedDiamond;
                const currentPaid = prices[this.p.speedDiamondTier];
                const targetPrice = prices[tier];
                const cost = targetPrice - currentPaid;

                if (this.p.diamond < cost) {
                    this.log('💎 다이아가 부족합니다!');
                    return;
                }

                this.p.diamond -= cost;
                this.p.speedDiamondTier = tier;

                const speedNames = ['', '1.5배속', '2.0배속'];
                this.log(`⚡ ${speedNames[tier]} 구매 완료! 현재 배속: ${this.getSpeedMultiplier().toFixed(1)}x`);

                this.updateUI();
                this.updateSpeedShopUI();
                this.saveProgress();
            }

            // 골드 배속 구매
            buyGoldSpeed() {
                if (this.p.speedGoldLevel >= 5) {
                    this.log('⚡ 최대 레벨입니다!');
                    return;
                }

                const goldPrices = GAME_PRICES.speedGold;
                const cost = goldPrices[this.p.speedGoldLevel];

                if (this.p.gold < cost) {
                    this.log('💰 골드가 부족합니다!');
                    return;
                }

                this.p.gold -= cost;
                this.p.speedGoldLevel++;

                const bonus = this.p.speedGoldLevel * 5;
                this.log(`🔧 배속 강화 Lv.${this.p.speedGoldLevel}! (+${bonus}%) 현재 배속: ${this.getSpeedMultiplier().toFixed(1)}x`);

                this.updateUI();
                this.updateSpeedShopUI();
                document.getElementById('shop-gold').innerText = NumFormat.format(this.p.gold);
                this.saveProgress();
            }

            // 뽑기 관련 함수
            openGacha() {
                this.closeAllOverlays();
                document.getElementById('gacha-overlay').style.display = 'flex';
                document.getElementById('gacha-diamond').innerText = NumFormat.format(this.p.diamond);
                document.getElementById('gacha-pity').innerText = this.p.pityCount;
                document.getElementById('gacha-result').style.display = 'none';
            }

            closeGacha() {
                this.restoreGameView();
            }

            doGacha(count) {
                const cost = count === 10 ? GAME_PRICES.gacha.ten : GAME_PRICES.gacha.single;
                if (this.p.diamond < cost) {
                    this.log('💎 다이아가 부족합니다!');
                    return;
                }

                this.p.diamond -= cost;
                const results = [];

                for (let i = 0; i < count; i++) {
                    this.p.pityCount++;
                    const grade = this.rollGrade();
                    const weaponsOfGrade = this.r.weapons.filter(w => w.grade === grade);
                    const weapon = weaponsOfGrade.length > 0
                        ? weaponsOfGrade[Math.floor(Math.random() * weaponsOfGrade.length)]
                        : this.r.weapons[1];
                    results.push({ weapon, grade });

                    // 10연차 보너스: 레어 이상 확정
                    if (count === 10 && i === 9 && !results.some(r => ['rare', 'epic', 'legendary'].includes(r.grade))) {
                        const rareWeapons = this.r.weapons.filter(w => ['rare', 'epic', 'legendary'].includes(w.grade));
                        if (rareWeapons.length > 0) {
                            results[9] = { weapon: rareWeapons[Math.floor(Math.random() * rareWeapons.length)], grade: 'rare' };
                        }
                    }
                }

                // 결과를 인벤토리에 추가
                results.forEach(r => {
                    this.addToInventory({ ...r.weapon, grade: r.grade });
                });

                // 가장 좋은 무기 자동 장착 (현재 장착보다 좋으면)
                const gradeOrder = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4 };
                const best = results.reduce((a, b) =>
                    gradeOrder[a.grade] > gradeOrder[b.grade] ? a : b
                );

                const currentAtk = this.p.equippedWeapon ? this.p.equippedWeapon.atk : 0;
                if (best.weapon.atk > currentAtk) {
                    // 인벤토리에서 방금 추가된 최고 무기 찾아서 장착
                    const bestIdx = this.p.inventory.findIndex(w => w.name === best.weapon.name && w.grade === best.grade);
                    if (bestIdx >= 0) {
                        this.equipWeapon(bestIdx);
                        this.log(`✨ ${best.weapon.name} 자동 장착! (공격력 +${best.weapon.atk})`);
                    }
                }

                // 결과 표시
                this.showGachaResult(results);
                this.updateUI();
                document.getElementById('gacha-diamond').innerText = NumFormat.format(this.p.diamond);
                document.getElementById('gacha-pity').innerText = this.p.pityCount;
            }

            rollGrade() {
                const gacha = this.r.gacha || FALLBACK_DATA.gacha;
                const pity = this.p.pityCount;

                // 천장 체크
                if (pity >= gacha.pity.legendary) {
                    this.p.pityCount = 0;
                    return 'legendary';
                }
                if (pity >= gacha.pity.epic && pity % gacha.pity.epic === 0) {
                    return 'epic';
                }

                // 확률 뽑기
                const rates = gacha.rates;
                const roll = Math.random() * 100;
                let sum = 0;
                for (const [grade, rate] of Object.entries(rates)) {
                    sum += rate;
                    if (roll < sum) return grade;
                }
                return 'common';
            }
            showGachaResult(results) {
                const container = document.getElementById('gacha-result');
                container.style.display = 'flex';
                container.style.flexWrap = 'wrap';
                container.style.justifyContent = 'center';
                container.style.gap = '10px';

                // 결과 HTML 생성
                container.innerHTML = results.map(r => {
                    const gradeInfo = this.getGradeInfo(r.grade);
                    const isImage = r.weapon.icon.indexOf('assets/') === 0;
                    const iconHtml = isImage ? `<img src="${r.weapon.icon}" style="width:40px;height:40px;">` : `<span style="font-size:30px">${r.weapon.icon}</span>`;

                    return `<div style="width:100px; padding:10px; background:rgba(0,0,0,0.3); border-radius:10px; border:2px solid ${gradeInfo.color}; display:flex; flex-direction:column; align-items:center;">
                                ${iconHtml}
                                <span style="color:${gradeInfo.color}; font-size:11px; margin-top:5px; font-weight:bold;">${gradeInfo.name}</span>
                                <span style="font-size:12px; margin-top:2px; text-align:center; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; width:100%;">${r.weapon.name}</span>
                            </div>`;
                }).join('');

                const best = results.reduce((a, b) => {
                    const order = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
                    return order.indexOf(a.grade) > order.indexOf(b.grade) ? a : b;
                });
                this.log(`🎰 ${results.length}회 뽑기! 최고: [${this.getGradeInfo(best.grade).name}] ${best.weapon.name}`);
            }

            getUpgradeCost(t) {
                // Use GAME_PRICES
                if (t === 'potion') return GAME_PRICES.potion;
                if (t === 'hpBoost') {
                    // Base 100, Growth 1.1? Or Fixed?
                    // Let's assume arithmetic or small geometric.
                    // User said "100G" in HTML.
                    // config.json might not have hpBoost.
                    // Let's use logic similar to others if not found, or fixed.
                    // config is: { base: 100, growth: 1.1 }
                    const count = (this.p.purchased && this.p.purchased.hpBoost) || 0;
                    return Math.floor(100 * Math.pow(1.1, count));
                }

                const keyMap = { upgrade: 'upgrade', aspd: 'aspd', critRate: 'critRate', critDmg: 'critDmg' };
                const config = GAME_PRICES[keyMap[t]];
                if (!config) return 0;

                const mapP = { upgrade: 'atk', aspd: 'aspd', critRate: 'critRate', critDmg: 'critDmg' };
                if (!this.p.purchased) this.p.purchased = { atk: 0, maxHp: 0, aspd: 0, critRate: 0, critDmg: 0 };
                const count = this.p.purchased[mapP[t]] || 0;

                return Math.floor(config.base * Math.pow(config.growth, count));
            }

            updateShopCosts() {
                const types = ['hpBoost', 'upgrade', 'aspd', 'critRate', 'critDmg'];
                const idMap = { hpBoost: 'shop-cost-hpBoost', upgrade: 'shop-cost-atk', aspd: 'shop-cost-aspd', critRate: 'shop-cost-critRate', critDmg: 'shop-cost-critDmg' };

                types.forEach(t => {
                    const cost = this.getUpgradeCost(t);
                    const el = document.getElementById(idMap[t]);
                    if (el) el.innerText = NumFormat.format(cost) + 'G';
                });
            }

            buy(t) {
                const cost = this.getUpgradeCost(t);

                if (this.p.gold < cost) {
                    this.log('💰 골드가 부족합니다!');
                    return;
                }

                if (t === 'hpBoost') {
                    this.p.gold -= cost;
                    this.p.maxHp += 25;
                    this.p.hp += 25; // 현재 체력도 같이 증가
                    this.p.purchased.hpBoost = (this.p.purchased.hpBoost || 0) + 1;
                    this.log(`💗 최대 체력 증가! (+25) 비용: ${NumFormat.format(cost)}G`);
                }
                else if (t === 'upgrade') {
                    this.p.gold -= cost;
                    this.p.atk += 5;
                    this.p.purchased.atk++;
                    this.log(`💪 공격력 강화! (+5) 비용: ${NumFormat.format(cost)}G`);
                }
                else if (t === 'aspd') {
                    if (this.p.aspd >= 5.0) { this.log("⚡ 최대 공격속도 도달!"); return; }
                    this.p.gold -= cost;
                    this.p.aspd += 0.1;
                    this.p.purchased.aspd++;
                    this.log(`⚡ 공격속도 강화! (+0.1) 비용: ${NumFormat.format(cost)}G`);
                }
                else if (t === 'critRate') {
                    this.p.gold -= cost;
                    this.p.critRate = Math.min(this.p.critRate + 1, 100);
                    this.p.purchased.critRate++;
                    this.log(`🎯 치명타확률 강화! (+1%) 비용: ${NumFormat.format(cost)}G`);
                }
                else if (t === 'critDmg') {
                    this.p.gold -= cost;
                    this.p.critDmg += 10;
                    this.p.purchased.critDmg++;
                    this.log(`💥 치명타배수 강화! (+10%) 비용: ${NumFormat.format(cost)}G`);
                }
                else if (t === 'gacha') {
                    // 가챠는 별도 처리 되지만 여기서 호출될 수도 있음 (기존 코드 유지)
                    // 하지만 doGacha 함수가 따로 있으므로 이곳의 gacha 로직은 사실상 레거시일 수 있음.
                    // 안전하게 유지.
                    if (this.p.gold >= 200) {
                        this.p.gold -= 200;
                        const wl = this.r.weapons;
                        const i = Math.floor(Math.random() * (wl.length - 1)) + 1;
                        this.p.wIdx = i;
                        this.log(`🎲 ${wl[i].name} 획득!`);
                    }
                }

                this.updateUI();
                this.updateHand();
                this.updateShopCosts(); // 가격 갱신
                document.getElementById('shop-gold').innerText = NumFormat.format(this.p.gold);
            }

            updateHand() {
                const w = this.r.weapons[this.p.wIdx];
                const em = document.getElementById('hand-emoji');
                const im = document.getElementById('hand-img');
                const isImage = w.icon.indexOf('http') === 0 || w.icon.indexOf('data:') === 0 || w.icon.indexOf('assets/') === 0;
                if (isImage) {
                    em.style.display = 'none'; im.style.display = 'block'; im.src = w.icon;
                } else {
                    im.style.display = 'none'; em.style.display = 'block'; em.innerText = w.icon;
                }
                document.getElementById('ui-weapon').innerText = w.name;
            }

            updateUI() {
                document.getElementById('ui-lv').innerText = this.p.lv;
                document.getElementById('ui-hp').innerText = NumFormat.format(this.p.hp);
                document.getElementById('ui-maxhp').innerText = NumFormat.format(this.p.maxHp);
                document.getElementById('ui-gold').innerText = NumFormat.format(this.p.gold);
                document.getElementById('ui-diamond').innerText = NumFormat.format(this.p.diamond);

                // EXP 바 업데이트
                document.getElementById('ui-exp').innerText = this.p.exp;
                document.getElementById('ui-maxexp').innerText = this.p.maxExp;
                const expPercent = (this.p.exp / this.p.maxExp) * 100;
                document.getElementById('exp-bar-fill').style.width = Math.min(100, expPercent) + '%';

                // 장착 무기 표시 (equippedWeapon 우선, 없으면 wIdx 폴백)
                const w = this.p.equippedWeapon || this.r.weapons[this.p.wIdx] || this.r.weapons[0];
                const weaponAtk = this.getWeaponAtk(w);
                const totalAtk = this.p.atk + weaponAtk;
                // Stat Panel removed


                // 무기 이름에 등급 색상 적용
                const gradeInfo = this.getGradeInfo(w.grade);
                const weaponEl = document.getElementById('ui-weapon');
                weaponEl.innerText = w.name;
                weaponEl.style.color = gradeInfo.color;

                // 무기 아이콘 업데이트
                const iconEl = document.getElementById('ui-weapon-icon');
                if (iconEl) {
                    const isImage = w.icon && (w.icon.indexOf('http') === 0 || w.icon.indexOf('data:') === 0 || w.icon.indexOf('assets/') === 0);
                    if (isImage) {
                        iconEl.innerHTML = `<img src="${w.icon}" style="width:24px;height:24px;object-fit:contain;vertical-align:middle;">`;
                    } else {
                        iconEl.innerHTML = w.icon || '🗡️';
                    }
                }

                // 배속 표시 업데이트
                const speedEl = document.getElementById('ui-speed');
                if (speedEl) {
                    const speed = this.getSpeedMultiplier();
                    speedEl.innerText = `⚡ ${speed.toFixed(1)}x`;
                    speedEl.style.color = speed > 1 ? '#f39c12' : '#888';
                }

                this.updateHand();

                // Stat Notification
                const noti = document.getElementById('stat-noti');
                if (noti) {
                    const points = this.p.availPoints || 0;
                    if (points > 0) noti.classList.add('active');
                    else noti.classList.remove('active');
                }
            }

            // 무기 공격력 계산 (기본 × 등급 배수 × 강화 보너스)
            getWeaponAtk(w) {
                const baseAtk = w.baseAtk || w.val || 0;
                const gradeInfo = this.getGradeInfo(w.grade);
                const enhancement = w.enhancement || 0;
                const enhanceBonus = 1 + enhancement * 0.05; // +5% per enhancement
                return Math.floor(baseAtk * gradeInfo.multiplier * enhanceBonus);
            }

            // 등급 정보 가져오기
            getGradeInfo(grade) {
                // Fix for Iron Sword or legacy items potentially missing grade
                if (!grade) grade = 'common';
                const grades = this.r.grades || FALLBACK_DATA.grades;
                return grades[grade] || grades['common'];
            }

            updateEHp() {
                if (!this.e) return;
                const p = (this.e.hp / this.e.maxHp) * 100;
                document.getElementById('hp-fill-enemy').style.width = Math.max(0, p) + "%";
            }

            showDmg(v, c, isP, isAlly = false, pos = null) {
                if (!this.showDamageText) return; // 옵션 체크
                const w = document.getElementById('game-container');
                const el = document.createElement('div');
                el.className = 'dmg-text';
                el.innerText = NumFormat.format(v) + (c ? "!" : "");

                if (pos) {
                    // Custom Position (for Allies)
                    el.style.left = pos.x + 'px';
                    el.style.top = pos.y + 'px';
                    // Ensure it doesn't overlap perfectly if multiple
                    el.style.transform = `translate(-50%, -50%) translate(${Math.random() * 10 - 5}px, ${Math.random() * 10 - 5}px)`;
                }

                if (isP) {
                    // Player took damage (Red)
                    el.style.color = 'red';
                    // Only set top if pos is not provided, otherwise pos dictates it
                    if (!pos) el.style.top = '60%';
                } else if (isAlly) {
                    // Ally hit enemy (Cyan)
                    el.style.color = '#3498db';
                    if (c) el.style.fontSize = "60px";
                } else if (c) {
                    // Player hit enemy (Crit - Orange)
                    el.style.color = 'orange';
                    el.style.fontSize = "70px";
                }

                w.appendChild(el);
                setTimeout(() => el.remove(), 800);
            }

            log(m) {
                const b = document.getElementById('log-box');
                b.innerHTML += `<div>${m}</div>`;
                b.scrollTop = b.scrollHeight;
            }

            // 스탯 패널
            openStatPanel() {
                this.closeAllOverlays();
                document.getElementById('stat-overlay').style.display = 'flex';
                this.updateStatPanel();
            }

            closeStatPanel() {
                this.restoreGameView();
            }

            updateStatPanel() {
                document.getElementById('avail-points').innerText = this.p.statPoints;
                document.getElementById('sp-atk').innerText = NumFormat.format(this.p.atk);
                document.getElementById('sp-atk-inv').innerText = `(+${this.p.invested.atk})`;
                document.getElementById('sp-maxHp').innerText = NumFormat.format(this.p.maxHp);
                document.getElementById('sp-maxHp-inv').innerText = `(+${this.p.invested.maxHp})`;
                document.getElementById('sp-aspd').innerText = this.p.aspd.toFixed(2);
                document.getElementById('sp-aspd-inv').innerText = `(+${this.p.invested.aspd})`;
                document.getElementById('sp-critRate').innerText = NumFormat.percent(this.p.critRate, 1);
                document.getElementById('sp-critRate-inv').innerText = `(+${this.p.invested.critRate})`;
                document.getElementById('sp-critDmg').innerText = NumFormat.percent(this.p.critDmg, 0);
                document.getElementById('sp-critDmg-inv').innerText = `(+${this.p.invested.critDmg})`;
                document.querySelectorAll('.stat-btn-add').forEach(btn => { btn.disabled = this.p.statPoints <= 0; });
            }

            investStat(statName) {
                if (this.p.statPoints <= 0) return;
                this.p.statPoints--;
                this.p.invested[statName]++;
                const increase = this.statPerPoint[statName];
                this.p[statName] += increase;
                if (statName === 'maxHp') this.p.hp += increase;
                if (statName === 'critRate' && this.p.critRate > 100) this.p.critRate = 100;
                this.updateStatPanel();
                this.updateUI();
                this.saveProgress(); // Ensure timestamp is recorded on start
            }

            async resetStats() {
                const confirmed = await this.showConfirmModal(
                    '🔄 스탯 초기화',
                    '정말 스탯을 초기화하시겠습니까?\n투자한 스탯 포인트가 모두 반환됩니다.',
                    [
                        { text: '초기화', value: true, style: 'background:#e74c3c' },
                        { text: '취소', value: false, style: 'background:#666' }
                    ]
                );
                if (!confirmed) return;

                const totalInvested = Object.values(this.p.invested).reduce((a, b) => a + b, 0);
                this.p.statPoints += totalInvested;
                this.p.atk = this.baseStats.atk;
                this.p.maxHp = this.baseStats.maxHp;
                this.p.aspd = this.baseStats.aspd;
                this.p.critRate = this.baseStats.critRate;
                this.p.critDmg = this.baseStats.critDmg;
                this.p.hp = this.p.maxHp;
                this.p.invested = { atk: 0, maxHp: 0, aspd: 0, critRate: 0, critDmg: 0 };
                this.updateStatPanel();
                this.updateUI();
                this.saveProgress();
                this.log('🔄 스탯이 초기화되었습니다!');
            }

            recalcStats() {
                this.p.atk = this.p.atkRaw;
                this.p.maxHp = this.p.maxHpRaw;
                this.p.aspd = this.p.aspdRaw;
                this.p.critRate = this.p.critRateRaw;
                this.p.critDmg = this.p.critDmgRaw;
            }

            // ===== 인벤토리 시스템 =====
            openInventory() {
                this.closeAllOverlays();
                document.getElementById('inventory-overlay').style.display = 'flex';
                this.renderInventory();
            }

            closeInventory() {
                this.restoreGameView();
            }

            // ===== 대장간 시스템 =====
            openSmith() {
                this.closeAllOverlays();
                document.getElementById('smith-overlay').style.display = 'flex';
                this.synthesisSlots = [null, null, null];
                this.enhanceTarget = null;
                this.switchSmithTab('synthesis');
            }

            closeSmith() {
                this.restoreGameView();
            }

            switchSmithTab(tab) {
                document.getElementById('smith-synthesis-tab').style.display = tab === 'synthesis' ? 'block' : 'none';
                document.getElementById('smith-enhance-tab').style.display = tab === 'enhance' ? 'block' : 'none';
                document.querySelectorAll('.smith-tab').forEach((btn, i) => {
                    btn.classList.toggle('active', (i === 0 && tab === 'synthesis') || (i === 1 && tab === 'enhance'));
                });
                if (tab === 'synthesis') {
                    this.synthesisSlots = [null, null, null];
                    this.renderSynthesisUI();
                    this.renderSynthesisWeaponList();
                } else {
                    this.enhanceTarget = null;
                    this.renderEnhanceUI();
                    this.renderEnhanceWeaponList();
                }
            }

            // === 합성 시스템 ===
            synthesisSlots = [null, null, null];
            selectedSynthSlot = 0;

            selectSynthesisSlot(slotIdx) {
                this.selectedSynthSlot = slotIdx;
                this.renderSynthesisWeaponList();
            }

            renderSynthesisWeaponList() {
                const container = document.getElementById('synth-weapon-list');
                const inventory = this.p.inventory || [];
                const usedIds = this.synthesisSlots.filter(s => s).map(s => s.id);

                container.innerHTML = '';
                inventory.forEach((w, idx) => {
                    if (usedIds.includes(w.id)) return; // 이미 슬롯에 있음
                    if (w.grade === 'legendary') return; // 전설은 합성 불가

                    const grade = this.getGradeInfo(w.grade);
                    const isImage = w.icon && (w.icon.indexOf('http') === 0 || w.icon.indexOf('data:') === 0 || w.icon.indexOf('assets/') === 0);
                    const iconHtml = isImage
                        ? `<img src="${w.icon}">`
                        : `<span style="font-size:25px;">${w.icon || '🗡️'}</span>`;

                    container.innerHTML += `
                        <div class="weapon-select-item" style="border-color:${grade.color}" onclick="game.addToSynthesisSlot(${idx})">
                            ${iconHtml}
                            ${w.enhancement ? `<span class="weapon-enhancement-badge">+${w.enhancement}</span>` : ''}
                        </div>
                    `;
                });

                if (container.innerHTML === '') {
                    container.innerHTML = '<p style="color:#888;text-align:center;grid-column:span 5;">합성 가능한 무기가 없습니다</p>';
                }
            }

            addToSynthesisSlot(invIdx) {
                const weapon = this.p.inventory[invIdx];
                if (!weapon) return;

                // 빈 슬롯 찾기
                const emptyIdx = this.synthesisSlots.findIndex(s => s === null);
                if (emptyIdx === -1) return; // 슬롯 꽉 참

                // 첫 번째 무기가 아니면 등급 확인
                const firstWeapon = this.synthesisSlots.find(s => s);
                if (firstWeapon && firstWeapon.grade !== weapon.grade) {
                    this.log('⚠️ 같은 등급의 무기만 합성할 수 있습니다!');
                    return;
                }

                this.synthesisSlots[emptyIdx] = { ...weapon, invIdx };
                this.renderSynthesisUI();
                this.renderSynthesisWeaponList();
            }

            removeSynthesisSlot(slotIdx) {
                this.synthesisSlots[slotIdx] = null;
                this.renderSynthesisUI();
                this.renderSynthesisWeaponList();
            }

            renderSynthesisUI() {
                const gradeOrder = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
                const gradeCosts = { common: 500, uncommon: 2000, rare: 10000, epic: 50000 };

                // 슬롯 렌더링
                for (let i = 0; i < 3; i++) {
                    const slot = document.getElementById(`synth-slot-${i}`);
                    const weapon = this.synthesisSlots[i];
                    if (weapon) {
                        const isImage = weapon.icon && (weapon.icon.indexOf('http') === 0 || weapon.icon.indexOf('data:') === 0 || weapon.icon.indexOf('assets/') === 0);
                        slot.innerHTML = isImage
                            ? `<img src="${weapon.icon}" onclick="game.removeSynthesisSlot(${i})">`
                            : `<span onclick="game.removeSynthesisSlot(${i})">${weapon.icon || '🗡️'}</span>`;
                        slot.classList.add('filled');
                    } else {
                        slot.innerHTML = '<span style="color:#666">+</span>';
                        slot.classList.remove('filled');
                    }
                }

                // 정보 업데이트
                const filledSlots = this.synthesisSlots.filter(s => s);
                const grade = filledSlots[0]?.grade;
                const gradeInfo = grade ? this.getGradeInfo(grade) : null;
                const nextGrade = grade ? gradeOrder[gradeOrder.indexOf(grade) + 1] : null;
                const nextGradeInfo = nextGrade ? this.getGradeInfo(nextGrade) : null;

                if (gradeInfo && nextGradeInfo) {
                    document.getElementById('synth-grade-info').innerHTML =
                        `<span style="color:${gradeInfo.color}">${gradeInfo.name}</span> → <span style="color:${nextGradeInfo.color}">${nextGradeInfo.name}</span>`;
                    document.getElementById('synth-cost').innerText = NumFormat.format(gradeCosts[grade]) + 'G';
                    document.getElementById('synth-result').innerHTML = `<span style="color:${nextGradeInfo.color}">?</span>`;

                    // 합성 결과 예상 공격력 표시
                    const weaponsOfGrade = this.r.weapons.filter(w => w.grade === nextGrade);
                    if (weaponsOfGrade.length > 0) {
                        const minAtk = Math.min(...weaponsOfGrade.map(w => this.getWeaponAtk(w)));
                        const maxAtk = Math.max(...weaponsOfGrade.map(w => this.getWeaponAtk(w)));
                        document.getElementById('synth-preview').style.display = 'block';
                        document.getElementById('synth-atk-preview').innerText = `+${NumFormat.format(minAtk)} ~ +${NumFormat.format(maxAtk)}`;
                    } else {
                        document.getElementById('synth-preview').style.display = 'none';
                    }
                } else {
                    document.getElementById('synth-grade-info').innerText = '등급을 선택하세요';
                    document.getElementById('synth-cost').innerText = '0G';
                    document.getElementById('synth-result').innerHTML = '<span style="color:#666">?</span>';
                    document.getElementById('synth-preview').style.display = 'none';
                }

                // 버튼 활성화
                const canSynth = filledSlots.length === 3 && nextGrade && this.p.gold >= gradeCosts[grade];
                document.getElementById('synth-btn').disabled = !canSynth;
            }

            doSynthesis() {
                const filledSlots = this.synthesisSlots.filter(s => s);
                if (filledSlots.length !== 3) return;

                const gradeOrder = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
                const gradeCosts = { common: 500, uncommon: 2000, rare: 10000, epic: 50000 };
                const grade = filledSlots[0].grade;
                const cost = gradeCosts[grade];
                const nextGrade = gradeOrder[gradeOrder.indexOf(grade) + 1];

                if (this.p.gold < cost) {
                    this.log('💰 골드가 부족합니다!');
                    return;
                }

                // 비용 차감
                this.p.gold -= cost;

                // 재료 무기 제거 (인덱스 역순으로 삭제)
                const removeIndices = filledSlots.map(s => s.invIdx).sort((a, b) => b - a);
                removeIndices.forEach(idx => this.p.inventory.splice(idx, 1));

                // 상위 등급 랜덤 무기 생성
                const weaponsOfGrade = this.r.weapons.filter(w => w.grade === nextGrade);
                const template = weaponsOfGrade[Math.floor(Math.random() * weaponsOfGrade.length)] || this.r.weapons[1];
                const newWeapon = {
                    ...template,
                    id: Date.now() + Math.random(),
                    enhancement: 0,
                    price: template.price || (template.baseAtk * 10)
                };

                this.p.inventory.push(newWeapon);

                const gradeInfo = this.getGradeInfo(nextGrade);
                this.log(`⚗️ 합성 성공! <span style="color:${gradeInfo.color}">[${gradeInfo.name}] ${newWeapon.name}</span> 획득!`);

                this.synthesisSlots = [null, null, null];
                this.renderSynthesisUI();
                this.renderSynthesisWeaponList();
                this.updateUI();
                this.saveProgress();
            }

            // === 강화 시스템 ===
            enhanceTarget = null;

            selectEnhanceWeapon(invIdx) {
                this.enhanceTarget = invIdx;
                this.renderEnhanceUI();
                this.renderEnhanceWeaponList();
            }

            renderEnhanceWeaponList() {
                const container = document.getElementById('enhance-weapon-list');
                // Combine inventory + equipped for enhancement
                let list = [...(this.p.inventory || [])];
                if (this.p.equippedWeapon) {
                    // Tag it as equipped for logic
                    const eq = { ...this.p.equippedWeapon, isEquipped: true };
                    // Prepend or Append? Prepend logic.
                    list.unshift(eq);
                }

                container.innerHTML = '';
                list.forEach((w, idx) => {
                    const grade = this.getGradeInfo(w.grade);
                    const isImage = w.icon && (w.icon.indexOf('http') === 0 || w.icon.indexOf('data:') === 0 || w.icon.indexOf('assets/') === 0);
                    const iconHtml = isImage
                        ? `<img src="${w.icon}">`
                        : `<span style="font-size:25px;">${w.icon || '🗡️'}</span>`;

                    // Adjust index selection logic. 
                    // Since "idx" here is loop index, we need to map it back to inventory index OR special 'equipped' flag.
                    // Actually, simpler to just store the object reference or a unique ID in the UI and lookup.
                    // BUT `selectEnhanceWeapon` expects an index.
                    // If we use index for 'list', we need to change `selectEnhanceWeapon` to use 'list' instead of 'this.p.inventory'.

                    const isSelected = this.enhanceTarget === idx;
                    const enh = w.enhancement || 0;
                    const eqBadge = w.isEquipped ? '<span style="position:absolute;top:0;right:0;background:red;font-size:8px;padding:2px;">E</span>' : '';

                    container.innerHTML += `
                        <div class="weapon-select-item ${isSelected ? 'selected' : ''}" style="border-color:${grade.color}" onclick="game.selectEnhanceWeapon(${idx})">
                            ${eqBadge}
                            ${iconHtml}
                            ${enh > 0 ? `<span class="weapon-enhancement-badge">+${enh}</span>` : ''}
                        </div>
                    `;
                });

                if (container.innerHTML === '') {
                    container.innerHTML = '<p style="color:#888;text-align:center;grid-column:span 5;">강화할 무기가 없습니다</p>';
                }
            }

            renderEnhanceUI() {
                const enhanceRates = [100, 100, 90, 90, 70, 70, 50, 50, 30, 30];
                const enhanceCosts = [100, 100, 300, 300, 800, 800, 2000, 2000, 5000, 5000];

                // Reconstruct list to find target
                let list = [...(this.p.inventory || [])];
                if (this.p.equippedWeapon) list.unshift({ ...this.p.equippedWeapon, isEquipped: true });

                if (this.enhanceTarget === null || !list[this.enhanceTarget]) {
                    document.getElementById('enhance-weapon-icon').innerHTML = '🗡️';
                    document.getElementById('enhance-weapon-name').innerText = '무기를 선택하세요';
                    document.getElementById('enhance-weapon-level').innerText = '';
                    document.getElementById('enhance-rate').innerText = '-';
                    document.getElementById('enhance-cost').innerText = '-';
                    document.getElementById('enhance-btn').disabled = true;
                    document.getElementById('enhance-preview').style.display = 'none';
                    return;
                }

                const weapon = list[this.enhanceTarget];
                const grade = this.getGradeInfo(weapon.grade);
                const enh = weapon.enhancement || 0;
                const isMax = enh >= 10;

                const isImage = weapon.icon && (weapon.icon.indexOf('http') === 0 || weapon.icon.indexOf('data:') === 0 || weapon.icon.indexOf('assets/') === 0);
                document.getElementById('enhance-weapon-icon').innerHTML = isImage
                    ? `<img src="${weapon.icon}" style="width:60px;height:60px;object-fit:contain;">`
                    : weapon.icon || '🗡️';
                document.getElementById('enhance-weapon-name').innerHTML = `<span style="color:${grade.color}">${weapon.name}</span>`;
                document.getElementById('enhance-weapon-level').innerText = isMax ? '+10 (MAX)' : `+${enh} → +${enh + 1}`;

                if (isMax) {
                    document.getElementById('enhance-rate').innerText = '-';
                    document.getElementById('enhance-cost').innerText = '-';
                    document.getElementById('enhance-fail').innerText = '-';
                    document.getElementById('enhance-btn').disabled = true;
                    document.getElementById('enhance-preview').style.display = 'none';
                } else {
                    const rate = enhanceRates[enh];
                    const cost = enhanceCosts[enh];
                    document.getElementById('enhance-rate').innerText = rate + '%';
                    document.getElementById('enhance-cost').innerText = NumFormat.format(cost) + 'G';
                    document.getElementById('enhance-fail').innerText = enh > 0 ? '-1' : '유지';
                    document.getElementById('enhance-btn').disabled = this.p.gold < cost;

                    // 강화 후 예상 공격력 표시
                    const currentAtk = this.getWeaponAtk(weapon);
                    const enhancedWeapon = { ...weapon, enhancement: enh + 1 };
                    const afterAtk = this.getWeaponAtk(enhancedWeapon);
                    const diff = afterAtk - currentAtk;

                    document.getElementById('enhance-preview').style.display = 'block';
                    document.getElementById('enhance-atk-current').innerText = `+${NumFormat.format(currentAtk)}`;
                    document.getElementById('enhance-atk-after').innerText = `+${NumFormat.format(afterAtk)}`;
                    document.getElementById('enhance-atk-diff').innerText = `(+${NumFormat.format(diff)})`;
                }
            }

            doEnhance() {
                if (this.enhanceTarget === null) return;

                const enhanceRates = [100, 100, 90, 90, 70, 70, 50, 50, 30, 30];
                const enhanceCosts = [100, 100, 300, 300, 800, 800, 2000, 2000, 5000, 5000];

                // Reconstruct list
                let list = [...(this.p.inventory || [])];
                if (this.p.equippedWeapon) list.unshift({ ...this.p.equippedWeapon, isEquipped: true });

                const wrapper = list[this.enhanceTarget];
                if (!wrapper) return;

                // Get ACTUAL object ref
                let weapon;
                if (wrapper.isEquipped) {
                    weapon = this.p.equippedWeapon;
                } else {
                    // Start of inventory items in 'list' is index 1 if equipped exists, else 0
                    const invIdx = this.p.equippedWeapon ? this.enhanceTarget - 1 : this.enhanceTarget;
                    weapon = this.p.inventory[invIdx];
                }
                if (!weapon) return;

                const enh = weapon.enhancement || 0;
                if (enh >= 10) return;

                const cost = enhanceCosts[enh];
                if (this.p.gold < cost) {
                    this.log('💰 골드가 부족합니다!');
                    return;
                }

                this.p.gold -= cost;

                const rate = enhanceRates[enh];
                const success = Math.random() * 100 < rate;

                if (success) {
                    weapon.enhancement = enh + 1;
                    this.log(`✨ 강화 성공! ${weapon.name} +${weapon.enhancement}`);
                } else {
                    if (enh > 0) {
                        weapon.enhancement = enh - 1;
                        this.log(`💔 강화 실패... ${weapon.name} +${weapon.enhancement}`);
                    } else {
                        this.log(`💔 강화 실패... (레벨 유지)`);
                    }
                }

                this.renderEnhanceUI();
                this.renderEnhanceWeaponList();
                this.updateUI();
                this.saveProgress();
            }


            renderInventory() {
                console.log('=== renderInventory CALLED ===');
                // 현재 장착 무기 표시 (equippedWeapon 우선, 없으면 wIdx 폴백)
                const eqDiv = document.getElementById('inv-equipped');
                console.log('eqDiv found:', !!eqDiv);
                const w = this.p.equippedWeapon || this.r.weapons[this.p.wIdx] || this.r.weapons[0];
                console.log('Weapon w:', w?.name, 'equippedWeapon:', this.p.equippedWeapon?.name, 'wIdx:', this.p.wIdx);

                if (w && w.name !== '맨주먹') {
                    const grade = this.getGradeInfo(w.grade);
                    const weaponAtk = this.getWeaponAtk(w);
                    const isImage = w.icon && (w.icon.indexOf('http') === 0 || w.icon.indexOf('data:') === 0 || w.icon.indexOf('assets/') === 0);
                    const iconHtml = isImage
                        ? `<img src="${w.icon}" style="width:40px;height:40px;object-fit:contain;">`
                        : `<span style="font-size:40px;">${w.icon || '🗡️'}</span>`;
                    const newHtml = `
                        ${iconHtml}
                        <div>
                            <div style="font-weight:bold;color:${grade.color}">${w.name}</div>
                            <div style="color:#e74c3c;font-size:12px;">공격력 +${weaponAtk}</div>
                            <div style="color:#888;font-size:10px;">${grade.name}</div>
                        </div>
                        <button class="btn-small" style="margin-left:auto;" onclick="game.unequipWeapon()">해제</button>
                    `;
                    console.log('Setting eqDiv.innerHTML with weapon:', w.name);
                    eqDiv.innerHTML = newHtml;
                    console.log('eqDiv.innerHTML NOW:', eqDiv.textContent?.substring(0, 30));
                } else {
                    eqDiv.innerHTML = '<span style="color:#888;">장착된 장비 없음 (맨주먹)</span>';
                }

                // 인벤토리 목록 표시
                const listDiv = document.getElementById('inv-list');
                const inventory = this.p.inventory || [];
                document.getElementById('inv-count').textContent = inventory.length;

                if (inventory.length === 0) {
                    listDiv.innerHTML = '<div style="grid-column:span 4;text-align:center;color:#666;padding:20px;">인벤토리가 비어있습니다</div>';
                    return;
                }

                listDiv.innerHTML = inventory.map((item, idx) => {
                    const grade = this.getGradeInfo(item.grade);
                    const isEquipped = this.p.equippedWeapon && this.p.equippedWeapon.id === item.id;
                    const weaponAtk = this.getWeaponAtk(item);
                    const enh = item.enhancement || 0;
                    const enhText = enh > 0 ? ` +${enh}` : '';
                    const isImage = item.icon && (item.icon.indexOf('http') === 0 || item.icon.indexOf('data:') === 0 || item.icon.indexOf('assets/') === 0);
                    const iconHtml = isImage
                        ? `<img src="${item.icon}" style="width:32px;height:32px;object-fit:contain;">`
                        : `<span style="font-size:28px;">${item.icon || '🗡️'}</span>`;
                    return `
                        <div class="inv-item" style="background:${grade.color}22;border:2px solid ${grade.color};border-radius:8px;padding:8px;text-align:center;cursor:pointer;${isEquipped ? 'opacity:0.5;' : ''}" 
                             onclick="game.showItemActions(${idx})">
                            ${iconHtml}
                            <div style="font-size:10px;color:${grade.color};overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${item.name}${enhText}</div>
                            <div style="font-size:9px;color:#e74c3c;">+${weaponAtk}</div>
                        </div>
                    `;
                }).join('');
            }

            async showItemActions(idx) {
                // 아이템 ID를 저장해서 인덱스 변경에 대응
                const item = this.p.inventory[idx];
                if (!item) return;
                const itemId = item.id;
                const grade = this.getGradeInfo(item.grade);
                const sellPrice = Math.floor((item.price || 100) * 0.25);
                const weaponAtk = this.getWeaponAtk(item);

                const action = await this.showConfirmModal(
                    `[${grade.name}] ${item.name}`,
                    `공격력: +${weaponAtk}\n\n이 아이템을 어떻게 하시겠습니까?`,
                    [
                        { text: '🗡️ 장착', value: 'equip', style: 'background:#2ecc71' },
                        { text: `💰 판매 (${sellPrice}G)`, value: 'sell', style: 'background:#f39c12' },
                        { text: '취소', value: 'cancel', style: 'background:#666' }
                    ]
                );

                console.log('=== showItemActions: Modal returned ===');
                console.log('action:', action);

                // 모달 닫힌 후 현재 인덱스 다시 찾기 (ID 기준)
                const currentIdx = this.p.inventory.findIndex(i => i.id === itemId);
                console.log('currentIdx:', currentIdx, 'itemId:', itemId);
                if (currentIdx === -1) {
                    console.log('Item not found, returning early');
                    return; // 이미 제거된 아이템
                }

                if (action === 'equip') {
                    console.log('=== EQUIP BRANCH ENTERED ===');
                    this.equipWeapon(currentIdx);
                    console.log('equipWeapon completed');
                } else if (action === 'sell') {
                    console.log('=== SELL BRANCH ENTERED ===');
                    this.sellItem(currentIdx);
                } else {
                    console.log('=== NO BRANCH MATCHED ===');
                    return;
                }

                // 강제 리플로우 트리거 후 렌더링
                const invOverlay = document.getElementById('inventory-overlay');
                void invOverlay.offsetHeight; // 강제 동기 리플로우
                this.renderInventory();
            }

            equipWeapon(idx) {
                const item = this.p.inventory[idx];
                if (!item) return;

                // 기존 장착 무기가 있으면 인벤토리로
                if (this.p.equippedWeapon) {
                    this.p.inventory.push(this.p.equippedWeapon);
                }

                // 새 무기 장착
                this.p.equippedWeapon = item;
                this.p.inventory.splice(idx, 1);

                // wIdx 업데이트 (기존 시스템 호환)
                const wepIdx = this.r.weapons.findIndex(w => w.name === item.name);
                if (wepIdx >= 0) this.p.wIdx = wepIdx;

                this.updateHand();
                // 3D Model Update
                if (window.game3d) window.game3d.equipWeapon(
                    wepIdx >= 0 ? wepIdx : 0,
                    this.p.equippedWeapon ? this.p.equippedWeapon.grade : 'common'
                );

                // Commented out: renderInventory is called by showItemActions
                // this.renderInventory();
                this.updateUI();
                this.saveProgress();
                this.log(`🗡️ ${item.name} 장착!`);
            }

            unequipWeapon() {
                if (!this.p.equippedWeapon) return;
                this.p.inventory.push(this.p.equippedWeapon);
                this.p.equippedWeapon = null;
                this.p.wIdx = 0; // 맨주먹
                this.updateHand();
                this.renderInventory();
                this.updateUI();
                this.saveProgress();
                this.log('👊 무기 해제, 맨주먹으로 전투');
            }

            sellItem(idx) {
                const item = this.p.inventory[idx];
                if (!item) return;
                const sellPrice = Math.floor((item.price || 100) * 0.25);
                this.p.gold += sellPrice;
                this.p.inventory.splice(idx, 1);
                this.renderInventory();
                this.updateUI();
                this.saveProgress();
                this.log(`💰 ${item.name} 판매! +${sellPrice}G`);
            }

            sortInventory(sortType) {
                const gradeOrder = { legendary: 0, epic: 1, rare: 2, uncommon: 3, common: 4 };

                switch (sortType) {
                    case 'grade':
                        this.p.inventory.sort((a, b) => (gradeOrder[a.grade] || 5) - (gradeOrder[b.grade] || 5));
                        break;
                    case 'atk':
                        this.p.inventory.sort((a, b) => b.atk - a.atk);
                        break;
                    case 'name':
                        this.p.inventory.sort((a, b) => a.name.localeCompare(b.name));
                        break;
                }
                this.renderInventory();
            }

            // 무기 획득 시 인벤토리에 추가
            addToInventory(weapon) {
                // 90칸 제한 체크
                const MAX_SLOTS = 90;
                if (this.p.inventory.length >= MAX_SLOTS) {
                    this.log('⚠️ 가방이 꽉 차서 전리품을 자동으로 획득할 수 없습니다.');
                    return false;
                }
                // 고유 ID 부여
                const newWeapon = {
                    ...weapon,
                    id: Date.now() + Math.random(),
                    price: weapon.price || (weapon.atk * 10)
                };
                this.p.inventory.push(newWeapon);
                this.saveProgress();
                return true;
            }

            // --- New Save/Load Logic ---

            saveProgress() {
                if (!this.autoSave) return;

                // Sync Diamond to Shared Logic
                SharedData.setDiamond(this.p.diamond);

                const saveData = {
                    p: this.p,
                    stage: this.stage,
                    autoSave: this.autoSave,
                    showDamageText: this.showDamageText,
                    savedAt: new Date().toISOString()
                };
                localStorage.setItem(`save_slot_${this.slotId}`, JSON.stringify(saveData));

                // Refresh Settings UI if open to show updated timestamp
                if (document.getElementById('settings-overlay').style.display === 'flex') {
                    this.updateSettingsSlotUI();
                }
            }

            load() {
                // Sync Diamond from Shared Logic
                this.p.diamond = SharedData.getDiamond();

                const saved = localStorage.getItem(`save_slot_${this.slotId}`);
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        // Merge logic
                        this.p = { ...this.p, ...data.p };
                        this.stage = data.stage || 1;
                        this.autoSave = data.autoSave !== undefined ? data.autoSave : true;
                        this.showDamageText = data.showDamageText !== undefined ? data.showDamageText : true;

                        // Compatibility: Ensure inventory is array
                        if (!Array.isArray(this.p.inventory)) this.p.inventory = [];

                    } catch (e) { console.error('Load failed', e); }
                } else {
                    // New Game defaults
                    this.resetPlayerState();
                }

                this.reload(); // Apply resources
                this.updateUI();
                this.renderPartyUI(); // Update buttons

                // Sync 3D weapon
                if (window.game3d) {
                    const wid = this.p.wIdx || 0;
                    window.game3d.equipWeapon(wid, this.p.equippedWeapon ? this.p.equippedWeapon.grade : 'common');
                }
            }

            resetPlayerState() {
                this.p = {
                    hp: 100, maxHp: 100, atk: 10, aspd: 1.0, critRate: 5, critDmg: 150,
                    atkRaw: 10, maxHpRaw: 100, aspdRaw: 1.0, critRateRaw: 5, critDmgRaw: 150,
                    gold: 0, diamond: 0, lv: 1, exp: 0, maxExp: 100, wIdx: 0, statPoints: 5, pityCount: 0,
                    invested: { atk: 0, maxHp: 0, aspd: 0, critRate: 0, critDmg: 0 },
                    purchased: { atk: 0, maxHp: 0, aspd: 0, critRate: 0, critDmg: 0 },
                    inventory: [],
                    equippedWeapon: null,
                    speedDiamondTier: 0,
                    speedGoldLevel: 0
                };
                this.stage = 1;
            }

            async resetProgress() {
                if (await this.showConfirmModal('캐릭터 초기화', `정말 슬롯 ${this.slotId} 데이터를 삭제하시겠습니까?`)) {
                    localStorage.removeItem(`save_slot_${this.slotId}`);
                    location.reload();
                }
            }

            wait(ms) { return new Promise(r => setTimeout(r, ms)); }

            showConfirmModal(title, message, buttons = [{ text: '확인', value: true, style: '' }, { text: '취소', value: false, style: 'background:#666' }]) {
                return new Promise(resolve => {
                    const modal = document.getElementById('confirm-modal');
                    const titleEl = document.getElementById('modal-title');
                    const messageEl = document.getElementById('modal-message');
                    const buttonsEl = document.getElementById('modal-buttons');

                    titleEl.textContent = title;
                    messageEl.textContent = message;

                    buttonsEl.innerHTML = buttons.map((btn, i) =>
                        `<button class="btn-save" style="${btn.style || ''};padding:10px 25px;min-width:80px;" data-value="${i}">${btn.text}</button>`
                    ).join('');

                    const handleClick = (e) => {
                        const idx = e.target.dataset.value;
                        if (idx !== undefined) {
                            modal.style.display = 'none';
                            buttonsEl.removeEventListener('click', handleClick);
                            requestAnimationFrame(() => {
                                requestAnimationFrame(() => {
                                    resolve(buttons[parseInt(idx)].value);
                                });
                            });
                        }
                    };
                    buttonsEl.addEventListener('click', handleClick);
                    modal.style.display = 'flex';
                });
            }

            async confirmHome() {
                const confirmed = await this.showConfirmModal(
                    '타이틀로 이동',
                    '현재 진행상황을 저장하고\n타이틀 화면으로 이동하시겠습니까?'
                );
                if (confirmed) {
                    this.saveProgress();
                    location.reload();
                }
            }
        }




        // Game3D class for Three.js handling (Character, Background, Weapons, VFX)
        // Phase 6: Audio Manager Skeleton
        const AudioManager = {
            playSfx(name) {
                // Placeholder: console.log(`🔊 Play SFX: ${name}`);
            },
            playBgm(name) {
                // Placeholder
            }
        };

        class Game3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.tunnel = [];
                this.speed = 0.05;
                this.clock = new THREE.Clock();
                this.weaponMesh = null;
                this.allyMeshes = {};

                // Character
                this.model = null;
                this.mixer = null;
                this.actions = {};
                this.activeAction = null;
                this.handBone = null;

                // VFX
                this.particles = [];
                this.shake = 0;
                this.baseCamPos = new THREE.Vector3(0, 1.5, 3);

                this.init();
            }

            shakeCamera(amount = 0.5) {
                this.shake = amount;
            }

            init() {
                const container = document.getElementById('game-canvas');

                // Responsive Full Screen
                const w = window.innerWidth;
                const h = window.innerHeight;

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);

                this.baseCamPos = new THREE.Vector3(0, 2.5, 6); // Zoomed out for full view
                this.camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 100);
                this.camera.position.copy(this.baseCamPos);

                // Handle Window Resize
                window.addEventListener('resize', () => {
                    if (!this.camera || !this.renderer) return;
                    const newW = window.innerWidth;
                    const newH = window.innerHeight;
                    this.camera.aspect = newW / newH;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(newW, newH);
                });

                // Quality Enhancement: Improved Renderer Settings
                this.renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    antialias: true,
                    powerPreference: 'high-performance' // Prefer dedicated GPU if available
                });
                this.renderer.setSize(w, h);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x for performance

                // Quality Enhancement: Improved Shadow Settings
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer, higher quality shadows

                container.innerHTML = ''; // Clear previous if any
                container.appendChild(this.renderer.domElement);

                // Lights
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); // Increased intensity
                hemiLight.position.set(0, 20, 0);
                this.scene.add(hemiLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.position.set(-3, 10, 5);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                // Phase 2: Create Skybox
                this.createSkybox();

                // Phase 2: Create Atmospheric Particles
                this.createAtmosphericParticles();

                // Environment (Grass, Road, Simple Scenery)
                this.createEnvironment();


                // Load Character (Embedded Base64 for Offline File Protocol Support)
                try {
                    const loader = new THREE.GLTFLoader();

                    // Base64 to ArrayBuffer Helper
                    const base64ToArrayBuffer = (base64) => {
                        const binary_string = window.atob(base64.split(',')[1]);
                        const len = binary_string.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binary_string.charCodeAt(i);
                        }
                        return bytes.buffer;
                    };

                    const modelData = base64ToArrayBuffer(SOLDIER_MODEL_DATA);

                    loader.parse(
                        modelData,
                        '',
                        (gltf) => {
                            this.model = gltf.scene;
                            this.scene.add(this.model);
                            this.scene.add(this.model);
                            this.model.position.set(0, 0, 1); // Normalized to Y=0 (Ground Level)
                            this.model.rotation.set(0, 0, 0); // Face Forward
                            // Create and Apply custom "Knight" Texture
                            const knightTex = this.createKnightTexture();

                            this.model.traverse((object) => {
                                if (object.isMesh) {
                                    object.castShadow = true;

                                    // Apply Texture to Armor
                                    if (object.name.includes('vanguard_Mesh')) {
                                        object.material.map = knightTex;
                                        object.material.color.setHex(0xffffff); // White base to show texture
                                        object.material.metalness = 0.8;
                                        object.material.roughness = 0.4;
                                        object.material.needsUpdate = true;
                                    }
                                    // Visor: Black Glass
                                    if (object.name.includes('vanguard_visor')) {
                                        object.material.color.setHex(0x111111);
                                        object.material.roughness = 0.1;
                                        object.material.metalness = 0.9;
                                    }
                                }
                            });

                            this.mixer = new THREE.AnimationMixer(this.model);
                            this.actions['Idle'] = this.mixer.clipAction(gltf.animations[0]);
                            this.actions['Run'] = this.mixer.clipAction(gltf.animations[1]);
                            this.actions['Walk'] = this.mixer.clipAction(gltf.animations[3]);

                            this.activeAction = this.actions['Idle'];
                            this.activeAction.play();

                            // Find Right Hand Bone
                            this.handBone = null;
                            this.model.traverse(child => {
                                if (child.isBone && child.name.includes('mixamorigRightHand')) {
                                    this.handBone = child;
                                }
                            });

                            if (this.handBone) {
                                this.attachWeaponToHand();
                            } else {
                                console.warn("Hand bone not found.");
                            }

                            if (this.weaponMesh && !this.handBone) {
                                // Fallback if no bone found yet
                                this.scene.add(this.weaponMesh);
                            }
                            console.log('💂 Embedded Knight Character Loaded');
                        },
                        (e) => console.error('Parse Error', e)
                    );
                } catch (e) {
                    console.error('GLTFLoader embedded setup failed:', e);
                }

                this.animate();
            }

            createKnightTexture() {
                // Procedural Texture Generation for "Plate Armor"
                const size = 512;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                // Base Metal
                ctx.fillStyle = '#8899a6'; // Steel Blue-Grey
                ctx.fillRect(0, 0, size, size);

                // Noise/Scratches
                for (let i = 0; i < 5000; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? '#aabbcc' : '#667788';
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    ctx.fillRect(x, y, 2, 2);
                }

                // Plates (Lines)
                ctx.strokeStyle = '#445566';
                ctx.lineWidth = 4;
                for (let y = 0; y < size; y += 64) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(size, y);
                    ctx.stroke();
                }

                // Rivets
                ctx.fillStyle = '#ccddff';
                for (let y = 0; y < size; y += 64) {
                    for (let x = 20; x < size; x += 100) {
                        ctx.beginPath();
                        ctx.arc(x, y + 32, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                const tex = new THREE.CanvasTexture(canvas);
                return tex;
            }

            // Phase 2: Create Skybox with Gradient
            createSkybox() {
                // Create a large sphere for skybox
                const skyGeo = new THREE.SphereGeometry(90, 32, 32);

                // Create canvas for gradient texture
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');

                // Default gradient (will be updated with updateBackgroundTheme)
                const gradient = ctx.createLinearGradient(0, 0, 0, 512);
                gradient.addColorStop(0, '#87CEEB'); // Sky blue at top
                gradient.addColorStop(0.7, '#B0C4DE'); // Light steel blue
                gradient.addColorStop(1, '#E6E6FA'); // Lavender at horizon

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);

                const skyTex = new THREE.CanvasTexture(canvas);
                const skyMat = new THREE.MeshBasicMaterial({
                    map: skyTex,
                    side: THREE.BackSide, // Render inside
                    fog: false
                });

                this.skybox = new THREE.Mesh(skyGeo, skyMat);
                this.scene.add(this.skybox);
                this.skyboxCanvas = canvas; // Store for updates
            }

            // Phase 2: Create Atmospheric Particles for Depth
            createAtmosphericParticles() {
                const particleCount = 50;
                const particles = new THREE.Group();

                for (let i = 0; i < particleCount; i++) {
                    const size = 0.1 + Math.random() * 0.2;
                    const geometry = new THREE.SphereGeometry(size, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.1 + Math.random() * 0.2
                    });

                    const particle = new THREE.Mesh(geometry, material);

                    // Random position in a large volume
                    particle.position.set(
                        (Math.random() - 0.5) * 40,
                        Math.random() * 20 - 2,
                        (Math.random() - 0.5) * 60
                    );

                    // Store initial position for animation
                    particle.userData = {
                        initialY: particle.position.y,
                        speed: 0.01 + Math.random() * 0.02,
                        range: 2 + Math.random() * 3
                    };

                    particles.add(particle);
                }

                this.scene.add(particles);
                this.atmosphericParticles = particles;
            }

            createEnvironment() {
                // Phase 4: Full 3D Textured Tunnel
                this.textureLoader = new THREE.TextureLoader();

                // Helper to create environment planes
                const createPlane = (w, h, name) => {
                    const geo = new THREE.PlaneGeometry(w, h); // Width, Height
                    // Use Standard Material for PBR lighting response
                    const mat = new THREE.MeshStandardMaterial({
                        roughness: 0.8,
                        metalness: 0.1,
                        side: THREE.FrontSide, // Only visible from inside
                        color: 0x888888 // Default grey until texture loads
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.name = name;
                    mesh.receiveShadow = true;
                    return mesh;
                };

                // Tunnel Dimensions
                const tunnelLength = 120; // Long enough to cover view
                const tunnelWidth = 9; // Reduced from 13 (70%) to show more side background
                const tunnelHeight = 12; // -2 to 10
                const centerZ = -50; // Center point of tunnel

                // 1. Floor
                this.floorMesh = createPlane(tunnelWidth, tunnelLength, 'floor');
                this.floorMesh.rotation.x = -Math.PI / 2;
                this.floorMesh.position.set(0, 0, centerZ); // Y=0
                this.scene.add(this.floorMesh);

                // 2. Ceiling
                this.ceilingMesh = createPlane(tunnelWidth, tunnelLength, 'ceiling');
                this.ceilingMesh.rotation.x = Math.PI / 2;
                this.ceilingMesh.position.set(0, tunnelHeight, centerZ); // Y=0 + Height
                this.scene.add(this.ceilingMesh);

                // 3. Walls (Left & Right)
                // PlaneGeometry(Width, Height) -> For walls, Width is Length(Z), Height is Height(Y)
                this.wallLeftMesh = createPlane(tunnelLength, tunnelHeight, 'wallLeft');
                this.wallLeftMesh.rotation.y = Math.PI / 2;
                this.wallLeftMesh.position.set(-tunnelWidth / 2, tunnelHeight / 2, centerZ); // Centered vertically at H/2
                this.scene.add(this.wallLeftMesh);

                this.wallRightMesh = createPlane(tunnelLength, tunnelHeight, 'wallRight');
                this.wallRightMesh.rotation.y = -Math.PI / 2;
                this.wallRightMesh.position.set(tunnelWidth / 2, tunnelHeight / 2, centerZ);
                this.scene.add(this.wallRightMesh);

                // Initial Theme Load (Default Forest)
                // Note: updateBackgroundTheme will be called again by Game init, but good to have default
                this.updateBackgroundTheme('숲');

                // Trees (Moved further out to not clip with walls)
                this.trees = [];
                const treeGeo = new THREE.ConeGeometry(1.5, 5, 8);
                const treeMat = new THREE.MeshStandardMaterial({ color: 0x114411, roughness: 0.9 });

                for (let i = 0; i < 12; i++) {
                    const treeLeft = new THREE.Mesh(treeGeo, treeMat);
                    // Position outside the walls (Walls are at +/- 10)
                    treeLeft.position.set(-12 - Math.random() * 5, 0.5, -10 - Math.random() * 100);
                    treeLeft.castShadow = true;
                    this.scene.add(treeLeft);
                    this.trees.push(treeLeft);

                    const treeRight = new THREE.Mesh(treeGeo, treeMat);
                    treeRight.position.set(12 + Math.random() * 5, 0.5, -10 - Math.random() * 100);
                    treeRight.castShadow = true;
                    this.scene.add(treeRight);
                    this.trees.push(treeRight);
                }
            }

            attachWeaponToHand() {
                if (!this.weaponMesh) return;

                if (this.handBone) {
                    this.weaponMesh.scale.set(1.5, 1.5, 1.5);
                    // Reset position relative to bone
                    this.weaponMesh.position.set(0, 0, 0);

                    // Rotation adjustments for Sword holding
                    // Initial guess: Blade up, Edge forward
                    this.weaponMesh.rotation.set(0, Math.PI / 2, 0);

                    this.handBone.add(this.weaponMesh);
                } else {
                    // Fallback
                    this.scene.add(this.weaponMesh);
                    if (this.model) {
                        this.weaponMesh.position.copy(this.model.position).add(new THREE.Vector3(0.5, 1, 1));
                    }
                }
            }

            createWeaponMesh(id, grade) {
                // Debug Log
                // console.log(`[createWeaponMesh] ID: ${id}, Grade: ${grade}`); 

                if (Number(id) === 0) {
                    return new THREE.Group(); // Invisible for Fists
                }

                const group = new THREE.Group();

                let type = 'sword';
                let weaponData = null;
                if (window.game && window.game.r && window.game.r.weapons) {
                    weaponData = window.game.r.weapons[id];

                    // Texture Support
                    if (weaponData && weaponData.icon && (weaponData.icon.indexOf('assets/') === 0 || weaponData.icon.indexOf('data:') === 0 || weaponData.icon.indexOf('http') === 0)) {
                        // NOTE: 'file://' protocol blocks TextureLoader in browsers due to CORS.
                        const isFile = window.location.protocol === 'file:';
                        const isDataUri = weaponData.icon.indexOf('data:') === 0;

                        if (!isFile || isDataUri) {
                            console.log(`[createWeaponMesh] Loading Texture: ${weaponData.icon}`);
                            const tex = new THREE.TextureLoader().load(weaponData.icon);
                            tex.colorSpace = THREE.SRGBColorSpace;
                            // Use a Plane for the image
                            const mat = new THREE.MeshStandardMaterial({
                                map: tex,
                                transparent: true,
                                side: THREE.DoubleSide,
                                alphaTest: 0.1
                            });
                            const size = 2.0;
                            const geo = new THREE.PlaneGeometry(size, size);
                            const mesh = new THREE.Mesh(geo, mat);

                            mesh.position.y = size * 0.4;

                            group.add(mesh);
                            return group;
                        } else {
                            console.warn("[createWeaponMesh] Skipping texture load due to file:// protocol to prevent invisible mesh.");
                            // Fall through to procedural
                        }
                    }

                    if (weaponData) {
                        const name = weaponData.name;
                        const nName = name.normalize('NFC');
                        // Debug
                        console.log(`[createWeaponMesh] Name: ${nName}, Codes: ${nName.charCodeAt(0)}, ${nName.charCodeAt(1)}`);

                        // Use Unicode escapes
                        // 도끼(\ub3c4\ub07c), 망치(\ub9dd\uce58), 묠니르(\ubb20\ub2c8\ub974), 낫(\ub0af), 창(\ucc3d)
                        if (nName.includes('\ub3c4\ub07c')) type = 'axe';
                        else if (nName.includes('\ub9dd\uce58') || nName.includes('\ubb20\ub2c8\ub974')) type = 'hammer';
                        else if (nName.includes('\ub0af')) type = 'scythe';
                        else if (nName.includes('\ucc3d')) type = 'spear';
                    } else {
                        console.warn(`[createWeaponMesh] Weapon Data missing for ID: ${id}`);
                    }
                } else {
                    console.warn(`[createWeaponMesh] window.game.r.weapons not accessible`);
                }

                // Materials
                const bladeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });
                const handleMat = new THREE.MeshStandardMaterial({ color: 0x553311 });

                if (type === 'axe') {
                    // Axe Geometry
                    // Handle
                    const handle = new THREE.Mesh(new THREE.BoxGeometry(0.08, 1.2, 0.08), handleMat);
                    handle.position.y = 0.3;
                    group.add(handle);

                    // Blade
                    const bladeGeo = new THREE.BoxGeometry(0.5, 0.4, 0.1);
                    const blade = new THREE.Mesh(bladeGeo, bladeMat);
                    blade.position.set(0.3, 0.7, 0);
                    group.add(blade);
                } else if (type === 'hammer') {
                    // Hammer Geometry
                    const handle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.0, 0.1), handleMat);
                    handle.position.y = 0.3;
                    group.add(handle);

                    const headGeo = new THREE.BoxGeometry(0.4, 0.3, 0.3);
                    const head = new THREE.Mesh(headGeo, bladeMat);
                    head.position.set(0, 0.8, 0);
                    group.add(head);
                } else if (type === 'scythe') {
                    // Scythe Geometry
                    const handle = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1.8, 0.06), handleMat);
                    handle.position.y = 0.6;
                    group.add(handle);

                    const bladeGeo = new THREE.ConeGeometry(0.1, 1.0, 4);
                    const blade = new THREE.Mesh(bladeGeo, bladeMat);
                    blade.position.set(0.4, 1.4, 0);
                    blade.rotation.z = -Math.PI / 4;
                    blade.rotation.y = Math.PI / 2; // Flat aspect
                    group.add(blade);
                } else if (type === 'spear') {
                    // Spear Geometry
                    const handle = new THREE.Mesh(new THREE.BoxGeometry(0.06, 2.0, 0.06), handleMat);
                    handle.position.y = 0.5;
                    group.add(handle);

                    const tipGeo = new THREE.ConeGeometry(0.1, 0.5, 8);
                    const tip = new THREE.Mesh(tipGeo, bladeMat);
                    tip.position.y = 1.5;
                    group.add(tip);
                } else {
                    // Default Sword
                    const bladeGeo = new THREE.BoxGeometry(0.1, 1.5, 0.05);
                    const blade = new THREE.Mesh(bladeGeo, bladeMat);
                    blade.position.y = 0.75;
                    blade.castShadow = true;
                    group.add(blade);

                    // Hilt
                    const hiltGeo = new THREE.BoxGeometry(0.3, 0.1, 0.1);
                    const hiltMat = new THREE.MeshStandardMaterial({ color: 0x885522 });
                    const hilt = new THREE.Mesh(hiltGeo, hiltMat);
                    hilt.position.y = 0;
                    group.add(hilt);
                    bladeMat.color.setHex(0xffaa00);
                }

                return group;
            }

            equipWeapon(id, grade) {
                if (this.weaponMesh) {
                    if (this.weaponMesh.parent) this.weaponMesh.parent.remove(this.weaponMesh);
                    else this.scene.remove(this.weaponMesh);
                }
                this.weaponMesh = this.createWeaponMesh(id, grade);
                this.attachWeaponToHand();
            }

            equipWeaponMeshToHand() {
                if (!this.weaponMesh) return;

                if (this.handBone) {
                    // Correct Scale for realistic weapon size (approx 1.5m length)
                    // Soldier is ~2 units tall. Sword should be ~1-1.5 units.
                    // Previous value 100 was too big? Or units are cm?
                    // Let's try 30 first (if units are roughly cm-ish relative to bone) or 100 if it was indeed correct.
                    // User said "Like a real person holding it". 
                    // Let's set it to 40 for now and adjust via feedback if needed.
                    this.weaponMesh.scale.set(1.5, 1.5, 1.5);

                    // Position adjustment to fit in hand grip
                    this.weaponMesh.position.set(0, 0, 0);

                    // Align rotation to match hand
                    this.weaponMesh.rotation.set(0, Math.PI / 2, 0); // Blade pointing forward assuming hand is palm-in
                    this.handBone.add(this.weaponMesh);
                } else {
                    // Fallback
                    this.scene.add(this.weaponMesh);
                    this.weaponMesh.position.set(2, -1, -3);
                    this.weaponMesh.rotation.x = 0.5;
                    this.weaponMesh.scale.set(1, 1, 1);
                }
            }

            addAlly(ally) {
                console.log(`[Game3D.addAlly] Called for Slot ${ally.slotId}`, ally);
                if (this.allyMeshes[ally.slotId]) {
                    this.scene.remove(this.allyMeshes[ally.slotId]);
                }
                // Pass grade for sync
                const grade = ally.weapon ? ally.weapon.grade : 'common';

                // Fix: Use wIdx (Type ID) instead of Unique ID
                let weaponId = ally.wIdx;

                // Fallback for old save data or missing wIdx
                if ((weaponId === undefined || weaponId === null) && ally.weapon && ally.weapon.name) {
                    const found = window.game.r.weapons.findIndex(w => w.name === ally.weapon.name);
                    if (found >= 0) weaponId = found;
                }
                // VISIBILITY FIX: If weaponId is 0 or invalid, default to 1 (Basic Sword)
                if (!weaponId) weaponId = 1;

                console.log(`[Game3D.addAlly] Creating mesh with ID: ${weaponId}, Grade: ${grade}`);
                const mesh = this.createWeaponMesh(weaponId, grade);

                // Dynamic Positioning
                let cx = 0;
                // Get active slot from main game instance
                const activeId = window.game ? window.game.slotId : 1;
                // Identify "others" logic matches Game.renderPartyUI
                const others = [1, 2, 3].filter(id => id !== activeId);

                // Determine if this ally is the "First" or "Second" other
                // others[0] -> Left (-2.5), others[1] -> Right (+2.5)
                const allyIndex = others.indexOf(ally.slotId);

                if (allyIndex === 0) cx = -2.5;       // Left Flank
                else if (allyIndex === 1) cx = 2.5;   // Right Flank
                else cx = -2.5;                       // Fallback

                mesh.scale.set(0.7, 0.7, 0.7);
                // Position slightly behind player (Z=-1) or aligned? 
                // Player is at 0, -2, 1? No, camera looks at 0,-1,-1. 
                // Checks Game3D.init: model.position.set(0, -2, 1). 
                // Let's put allies at Z=0 (slightly behind player's Z=1) or Z=1 aligned.
                // Original code was Z=-4 (behind). Let's bring them closer.
                // Player Z=1. Let's put allies at Z=0.
                mesh.position.set(cx, -1.5, 0);

                // Add Level Text Sprite
                if (ally.lv) {
                    const sprite = this.createLevelSprite(ally.lv);
                    sprite.position.set(0, 2.5, 0); // Above the sword
                    mesh.add(sprite); // Attach to weapon mesh group
                }

                this.scene.add(mesh);
                this.allyMeshes[ally.slotId] = mesh;
            }

            createLevelSprite(lv) {
                const canvas = document.createElement('canvas');
                canvas.width = 128; // Increased resolution
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, 0, 128, 64);
                ctx.font = 'bold 32px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const text = `Lv.${lv}`;
                ctx.fillText(text, 64, 32);
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(1, 0.5, 1);
                return sprite;
            }

            getAllyScreenPosition(slotId) {
                const mesh = this.allyMeshes[slotId];
                if (!mesh) return null;
                // Get position above the mesh (where Level text is, roughly Y=2.5)
                const pos = mesh.position.clone();
                pos.y += 3.5; // Slightly higher than Level Sprite (Y=2.5)
                pos.project(this.camera);
                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(pos.y * 0.5) + 0.5) * window.innerHeight;
                return { x, y };
            }

            removeAlly(slotId) {
                console.log(`[Game3D.removeAlly] Removing Slot ${slotId}`);
                if (this.allyMeshes[slotId]) {
                    this.scene.remove(this.allyMeshes[slotId]);
                    delete this.allyMeshes[slotId];
                }
            }

            // Quality Enhancement: Dynamic Background Theme
            // Quality Enhancement: Dynamic Background Theme
            updateBackgroundTheme(themeName) {
                if (!this.scene) return;

                // Hide CSS Tunnel overlay
                const cssTunnel = document.querySelector('.tunnel-container');
                if (cssTunnel) cssTunnel.style.display = 'none';

                // Texture Mappings
                const themeTextures = {
                    '숲': {
                        floor: 'theme_grass_floor.png',
                        wall: 'theme_grass_wall.png',
                        ceiling: 'theme_grass_ceiling.png',
                        color: 0xffffff
                    },
                    '던전': {
                        floor: 'theme_cave_floor.png',
                        wall: 'theme_cave_wall.png',
                        ceiling: 'theme_cave_ceiling.png',
                        color: 0x8888aa // Blue-ish tint
                    },
                    '용암동굴': {
                        floor: 'theme_cave_floor.png',
                        wall: 'theme_cave_wall.png',
                        ceiling: 'theme_cave_ceiling.png',
                        color: 0xffaaaa // Red-ish tint for lava
                    },
                    '얼음성': {
                        floor: 'theme_snow_floor.png',
                        wall: 'theme_snow_wall.png',
                        ceiling: 'theme_snow_ceiling.png',
                        color: 0xddffff
                    },
                    '마왕성': {
                        floor: 'theme_castle_floor.png',
                        wall: 'theme_castle_wall.png',
                        ceiling: 'theme_castle_ceiling.png',
                        color: 0xaa88ff // Purple tint
                    }
                };

                // Skybox Gradients (Phase 2 - kept)
                const skyboxGradients = {
                    '던전': { top: '#2a2a3d', mid: '#1a1a2e', bottom: '#0f0f1e' },
                    '숲': { top: '#87CEEB', mid: '#B0C4DE', bottom: '#E6E6FA' },
                    '용암동굴': { top: '#8B2500', mid: '#CD5C5C', bottom: '#FFA07A' },
                    '얼음성': { top: '#B0E0E6', mid: '#E0FFFF', bottom: '#F0F8FF' },
                    '마왕성': { top: '#1a0033', mid: '#4B0082', bottom: '#8B008B' }
                };

                const currentTexSet = themeTextures[themeName] || themeTextures['숲'];
                const basePath = 'assets/textures/';

                // Helper to load and apply texture
                const applyTex = (mesh, filename, repeatX, repeatY, colorTint) => {
                    if (!mesh || !this.textureLoader) return;

                    // Preserve previous offset for seamless transitions
                    const prevOffset = (mesh.material && mesh.material.map)
                        ? mesh.material.map.offset.clone()
                        : new THREE.Vector2(0, 0);

                    const fullPath = basePath + filename;
                    this.textureLoader.load(fullPath, (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace;
                        tex.wrapS = THREE.RepeatWrapping;
                        tex.wrapT = THREE.RepeatWrapping;
                        tex.repeat.set(repeatX, repeatY);

                        // Apply preserved offset for continuity
                        tex.offset.copy(prevOffset);

                        // Anisotropy for sharp angles
                        if (this.renderer.capabilities.getMaxAnisotropy) {
                            tex.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
                        }

                        if (mesh.material) {
                            mesh.material.map = tex;
                            mesh.material.color.setHex(colorTint || 0xffffff);
                            mesh.material.needsUpdate = true;
                        }
                    });
                };

                // Apply Textures w/ Tint
                // Floor: 20x120 -> Repeat 1x6
                applyTex(this.floorMesh, currentTexSet.floor, 1, 6, currentTexSet.color);

                // Ceiling: 20x120 -> Repeat 1x6
                applyTex(this.ceilingMesh, currentTexSet.ceiling, 1, 6, currentTexSet.color);

                // Walls: 120x12 -> Repeat 6x1 (Walls are long horizontally in UV space?)
                // Wall Geometry is (120, 12).
                // If UV matches geometry, u=0..1 is width(120), v=0..1 is height(12).
                // We want texture to tile properly. Texture likely 1:1 aspect.
                // 120/12 = 10. So repeat X should be 10?
                applyTex(this.wallLeftMesh, currentTexSet.wall, 6, 1, currentTexSet.color);
                applyTex(this.wallRightMesh, currentTexSet.wall, 6, 1, currentTexSet.color);

                // Update Background Color / Skybox
                const themeBgColors = {
                    '던전': 0x2a2a3d, '숲': 0x87CEEB, '용암동굴': 0x8B2500,
                    '얼음성': 0xADD8E6, '마왕성': 0x1a0033
                };
                const bgColor = themeBgColors[themeName] || 0x87CEEB;
                this.scene.background.setHex(bgColor);

                if (this.skybox && this.skyboxCanvas) {
                    const gradient = skyboxGradients[themeName] || skyboxGradients['숲'];
                    const ctx = this.skyboxCanvas.getContext('2d');
                    const grad = ctx.createLinearGradient(0, 0, 0, 512);
                    grad.addColorStop(0, gradient.top);
                    grad.addColorStop(0.5, gradient.mid);
                    grad.addColorStop(1, gradient.bottom);
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 512, 512);
                    this.skybox.material.map.needsUpdate = true;
                }

                console.log(`🎨 Background theme updated: ${themeName}`);
            }

            triggerAllyAttack(slotId) {
                const mesh = this.allyMeshes[slotId];
                if (mesh) {
                    // Fix: Reverse Swing (User Request: "Opposite direction")
                    // Previously += 1 (Down/Forward?). Now -= 1 (Up/Backward?) or vice versa.
                    // Let's assume user wants it to look like a backswing or just different.
                    mesh.rotation.x -= 1;
                    setTimeout(() => mesh.rotation.x += 1, 200);
                }
            }

            setAnimation(name) {
                if (!this.mixer || !this.actions[name]) return;
                if (this.activeAction === this.actions[name]) return;

                const prev = this.activeAction;
                const next = this.actions[name];

                if (prev) prev.fadeOut(0.2);
                next.reset().fadeIn(0.2).play();
                this.activeAction = next;
            }

            attack() {
                this.spawnParticles(15);
                // Maybe lunge?
                // if(this.model) this.model.position.z += 0.5; setTimeout(()=>this.model.position.z-=0.5, 200);
            }

            spawnParticles(count = 20) {
                if (!this.particles) this.particles = [];
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                for (let i = 0; i < count; i++) {
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(0, 0, -2); // Near impact
                    const velocity = new THREE.Vector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
                    this.scene.add(mesh);
                    this.particles.push({ mesh, velocity, life: 1.0 });
                }
            }

            updateParticles(delta) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= delta * 2;
                    p.mesh.position.addScaledVector(p.velocity, delta);
                    p.mesh.rotation.x += delta;
                    if (p.life <= 0) {
                        this.scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = this.clock.getDelta();

                if (this.mixer) this.mixer.update(delta);
                this.updateParticles(delta);

                if (window.game && window.game.state === 'BATTLE') {
                    this.setAnimation('Run');

                    // Slower movement for better feel
                    const worldMove = this.speed * 1.0;

                    // Scroll Textures for Infinite Tunnel Effect
                    // Direction Fixed: Use += to move texture "towards" camera (visual flow)
                    const texSpeed = 0.05; // Reduced from 0.1 for slower background

                    if (this.floorMesh && this.floorMesh.material.map) {
                        this.floorMesh.material.map.offset.y += worldMove * texSpeed;
                    }
                    if (this.ceilingMesh && this.ceilingMesh.material.map) {
                        this.ceilingMesh.material.map.offset.y += worldMove * texSpeed;
                    }

                    // Walls: Scroll along length
                    if (this.wallLeftMesh && this.wallLeftMesh.material.map) {
                        this.wallLeftMesh.material.map.offset.x += worldMove * texSpeed;
                    }
                    if (this.wallRightMesh && this.wallRightMesh.material.map) {
                        this.wallRightMesh.material.map.offset.x -= worldMove * texSpeed;
                    }

                    // Move Trees (Physical Objects)
                    if (this.trees) {
                        this.trees.forEach(tree => {
                            tree.position.z += worldMove; // Trees move +Z (towards camera)
                            if (tree.position.z > 10) {
                                tree.position.z = -90; // Respawn further back
                            }
                        });
                    }
                } else {
                    this.setAnimation('Idle');
                }

                // Phase 6: Camera Shake Effect (Fixed Phase 7: No Drift)
                // Always reset to base position first
                this.camera.position.copy(this.baseCamPos);

                if (this.shake > 0) {
                    const shakeAmount = this.shake * 0.5;
                    this.camera.position.x += (Math.random() - 0.5) * shakeAmount;
                    this.camera.position.y += (Math.random() - 0.5) * shakeAmount;
                    this.camera.position.z += (Math.random() - 0.5) * shakeAmount;
                    this.shake -= delta * 2.0; // Decay
                    if (this.shake < 0) this.shake = 0;
                }

                // Phase 2: Animate atmospheric particles (always animate, not just in battle)
                if (this.atmosphericParticles) {
                    const time = Date.now() * 0.001;
                    this.atmosphericParticles.children.forEach(particle => {
                        const data = particle.userData;
                        particle.position.y = data.initialY + Math.sin(time * data.speed) * data.range;
                    });
                }

                // Phase 8: Enemy Approach Animation (Lerp)
                if (this.currentEnemyMesh && this.enemyTargetZ !== undefined) {
                    // Smoothly move enemy to target Z
                    // Speed factor 2.0 -> Reaches usually in ~1-1.5s
                    const speed = 3.0 * delta;
                    this.currentEnemyMesh.position.z += (this.enemyTargetZ - this.currentEnemyMesh.position.z) * speed;

                    // Stop jitter when close
                    if (Math.abs(this.currentEnemyMesh.position.z - this.enemyTargetZ) < 0.1) {
                        this.currentEnemyMesh.position.z = this.enemyTargetZ;
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }

            // --- 3D Enemy System ---
            spawnEnemy(data, isBoss) {
                this.removeEnemy(); // Clear existing

                // Determine if Image or Emoji
                const isImage = data.icon && (data.icon.indexOf('http') === 0 || data.icon.indexOf('data:') === 0 || data.icon.indexOf('assets/') === 0);

                if (isImage) {
                    // Check if file protocol blocks texture
                    const isFile = window.location.protocol === 'file:';
                    const isDataUri = data.icon.indexOf('data:') === 0;

                    if (!isFile || isDataUri) {
                        new THREE.TextureLoader().load(data.icon, (tex) => {
                            tex.colorSpace = THREE.SRGBColorSpace;
                            const mat = new THREE.SpriteMaterial({ map: tex });
                            this.createEnemySprite(mat, isBoss);
                        }, undefined, (err) => {
                            console.warn("Enemy Texture Load Failed, fallback to Emoji", err);
                            this.spawnEmojiEnemy(data.icon || "👺", isBoss);
                        });
                    } else {
                        // Fallback for local file protocol
                        this.spawnEmojiEnemy(data.icon || "👺", isBoss);
                    }
                } else {
                    this.spawnEmojiEnemy(data.icon || "👾", isBoss);
                }
            }

            spawnEmojiEnemy(emoji, isBoss) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.font = '180px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = isBoss ? '#ff0000' : '#ffffff'; // Red glow for boss? No, text color.
                ctx.shadowBlur = 20;
                ctx.shadowColor = isBoss ? 'gold' : 'black';

                ctx.fillText(emoji, 128, 148); // Vertical adjust

                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex });
                this.createEnemySprite(mat, isBoss);
            }

            createEnemySprite(material, isBoss) {
                const sprite = new THREE.Sprite(material);
                // Size: Boss bigger
                const scale = isBoss ? 5.0 : 3.5;
                sprite.scale.set(scale, scale, 1);

                // Start Position: Far away in the tunnel
                const startZ = -60;
                const endZ = -2; // In front of character (who is at Z=1? No, World Y=0 for floor. Character Z=1? Let's check.)
                // Character was at Z=1. Camera Z=6. 
                // So Enemy at Z=-2 is deeper in screen. 

                sprite.position.set(0, 2.5, startZ); // Y=2.5 to float/stand? 
                // Character Y=0 (Ground). Sprite origin is center. 
                // If Scale=3.5, Height is 3.5. Center at 1.75 puts feet at 0.
                sprite.position.y = scale / 2;

                this.scene.add(sprite);
                this.currentEnemyMesh = sprite;
                this.enemyTargetZ = endZ;

                // Log
                console.log(`[Game3D] Enemy Spawned at Z=${startZ}, approaching ${endZ}`);
            }

            removeEnemy() {
                if (this.currentEnemyMesh) {
                    this.scene.remove(this.currentEnemyMesh);
                    if (this.currentEnemyMesh.material.map) this.currentEnemyMesh.material.map.dispose();
                    this.currentEnemyMesh.material.dispose();
                    this.currentEnemyMesh = null;
                }
            }
        }

        // 게임 초기화 (async)
        window.game = null;
        window.game3d = null; // Global 3D instance
        (async () => {
            try {
                await settings.init();
                // Init 3D first so it's ready
                try {
                    window.game3d = new Game3D();
                } catch (e) {
                    console.warn("⚠️ 3D Game Init Failed (WebGL/Assets issue):", e);
                }

                window.game = new Game();

                // Sync initial 3D weapon
                if (window.game.p.equippedWeapon && window.game3d) {
                    window.game3d.equipWeapon(window.game.p.equippedWeapon.id, window.game.p.equippedWeapon.grade);
                }

                // Global click listener for 3D attack sync
                document.getElementById('game-container').addEventListener('mousedown', (e) => {
                    if (window.game && window.game.state === 'BATTLE') {
                        window.game.attack();
                        if (window.game3d) window.game3d.attack();
                    }
                });

                console.log('🎮 Game initialized with JSON data');
            } catch (initErr) {
                console.error("❌ Critical Game Initialization Failure:", initErr);
                alert("게임 초기화에 실패했습니다. (Game Init Failed)\n" + initErr.message);
            }
        })();
    </script>
</body>

</html>